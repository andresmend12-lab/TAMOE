<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>Detalle | Tamoe</title>
    <link rel="icon" href="imagotipo_tamoe.png" type="image/png"/>
    <link href="https://fonts.googleapis.com" rel="preconnect"/>
    <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600;700;800&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet"/>
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <script id="tailwind-config">
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        primary: "#e619a1",
                        "background-light": "#f8f6f7",
                        "background-dark": "#21111c",
                        "surface-dark": "#2f1a28",
                        "surface-darker": "#1a0d15",
                        "text-muted": "#c893b6",
                        "border-dark": "#3a2330"
                    },
                    fontFamily: { display: ["Manrope", "sans-serif"] },
                    borderRadius: {
                        DEFAULT: "0.25rem",
                        lg: "0.5rem",
                        xl: "0.75rem",
                        "2xl": "1rem",
                        full: "9999px"
                    },
                },
            },
        }
    </script>
    <script>
        (function () {
            const applyTheme = () => {
                const stored = localStorage.getItem("theme");
                if (stored === "dark") {
                    document.documentElement.classList.add("dark");
                    return;
                }
                document.documentElement.classList.remove("dark");
            };

            try {
                if (window.parent && window.parent.document) {
                    if (window.parent.document.documentElement.classList.contains("dark")) {
                        document.documentElement.classList.add("dark");
                    }
                }
            } catch (e) {
                // Ignore cross-frame access errors.
            }

            applyTheme();
            window.addEventListener("storage", (event) => {
                if (event.key === "theme") {
                    applyTheme();
                }
            });
        })();
    </script>
    <style>
        :root {
            --scroll-track: #f1f1f1;
            --scroll-thumb: #d1d5db;
            --scroll-thumb-hover: #e619a1;
        }
        .dark {
            --scroll-track: #21111c;
            --scroll-thumb: #47243b;
            --scroll-thumb-hover: #e619a1;
        }
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: var(--scroll-track); }
        ::-webkit-scrollbar-thumb { background: var(--scroll-thumb); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--scroll-thumb-hover); }
        #description-view {
            border: 0;
            background: transparent;
            box-shadow: none;
            padding: 0;
        }
        #description-input {
            border: 0;
            background: transparent;
            box-shadow: none;
            outline: none;
        }
    </style>
</head>
<body class="bg-background-light dark:bg-background-dark text-gray-900 dark:text-white font-display overflow-hidden flex flex-col h-screen">
    <div class="flex flex-1 overflow-hidden">
        <main class="flex-1 flex flex-col overflow-y-auto relative">
            <div class="px-6 py-6 flex flex-col gap-6 max-w-none mx-auto w-full">
                <!-- Breadcrumb -->
                <div id="breadcrumb" class="hidden flex flex-wrap gap-2 items-center text-sm text-text-muted"></div>

                <!-- Title block -->
                <div class="flex flex-wrap justify-between items-start gap-4">
                    <div class="flex flex-col gap-2">
                        <div class="flex items-center gap-2">
                            <span id="type-chip" class="bg-primary/15 text-primary text-xs font-bold px-2.5 py-1 rounded-md border border-primary/30 uppercase tracking-wide">...</span>
                            <span id="created-chip" class="text-text-muted text-xs bg-gray-100 dark:bg-surface-dark px-2 py-1 rounded-md">...</span>
                        </div>
                        <h2 id="item-title" class="text-3xl md:text-4xl font-extrabold leading-tight tracking-tight text-gray-900 dark:text-white">Cargando...</h2>
                        <p id="item-manage" class="text-text-muted text-sm font-mono">...</p>
                    </div>
                    <div class="flex gap-2"></div>
                </div>

                <div class="grid gap-6 max-w-none mx-auto w-full lg:grid-cols-[minmax(0,1fr)_320px]">
                    <div class="flex flex-col gap-6 min-w-0">
                        <section class="bg-white dark:bg-surface-darker border border-border-dark rounded-xl p-5 shadow-xl">
                        <div class="flex items-center justify-between gap-2 mb-2">
                            <h3 class="text-gray-900 dark:text-white text-lg font-bold flex items-center gap-2">
                                <span class="material-symbols-outlined text-primary">article</span>
                                Descripci&#xF3;n
                            </h3>
                        </div>
                        <div id="description-view" class="w-full px-0 py-1 text-gray-900 dark:text-white whitespace-pre-line"></div>
                        <textarea id="description-input" class="hidden w-full bg-transparent text-gray-900 dark:text-white px-0 py-1 border-0 focus:ring-0 focus:border-transparent placeholder:text-text-muted resize-y min-h-[80px] max-h-[200px] overflow-y-auto" placeholder="Escribe una descripci&#xF3;n..."></textarea>
                        <div class="mt-3 flex items-center justify-between gap-2">
                            <span id="description-status" class="text-xs text-text-muted"></span>
                            <div class="flex items-center gap-2">
                                <button id="edit-description" class="size-8 rounded-md border border-border-dark bg-white dark:bg-surface-dark text-text-muted hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-white/5 transition-colors" aria-label="Editar descripci&#xF3;n">
                                    <span class="material-symbols-outlined text-[18px]">edit</span>
                                </button>
                                <button id="save-description" class="hidden h-8 px-3 rounded-md bg-primary hover:bg-primary/90 text-white text-xs font-bold transition-colors">
                                    Guardar
                                </button>
                            </div>
                        </div>
                        </section>

                        <section class="bg-white dark:bg-surface-darker border border-border-dark rounded-xl p-5 shadow-xl">
                        <h3 class="text-gray-900 dark:text-white text-lg font-bold flex items-center gap-2 mb-3">
                            <span class="material-symbols-outlined text-primary">account_tree</span>
                            Actividades
                        </h3>
                        <div id="activities-list" class="flex flex-col gap-2 text-sm text-text-muted">
                            <p class="text-text-muted text-sm">No hay elementos.</p>
                        </div>
                        </section>

                        <section class="bg-white dark:bg-surface-darker border border-border-dark rounded-xl p-5 shadow-xl">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-gray-900 dark:text-white text-lg font-bold flex items-center gap-2">
                                <span class="material-symbols-outlined text-primary">forum</span>
                                Comentarios
                            </h3>
                            <span id="comment-count" class="text-xs text-text-muted">0</span>
                        </div>

                        <div id="comments-list" class="flex flex-col gap-3 text-sm max-h-[520px] overflow-y-auto pr-1"></div>

                        <div class="mt-4 flex flex-col gap-2">
                            <label class="text-xs font-bold uppercase tracking-wide text-text-muted">A&#xF1;adir comentario</label>
                            <textarea id="comment-input" class="w-full bg-white dark:bg-background-dark text-gray-900 dark:text-white rounded-lg p-3 border border-border-dark focus:ring-1 focus:ring-primary focus:border-primary/50 placeholder:text-text-muted resize-y min-h-[100px]" placeholder="Escribe tu comentario..."></textarea>
                            <div class="flex items-center justify-between gap-3">
                                <span id="comment-helper" class="text-xs text-text-muted">Inicia sesi&#xF3;n para comentar.</span>
                                <button id="comment-submit" class="flex items-center gap-2 h-10 px-4 rounded-lg bg-primary hover:bg-primary/90 text-white text-sm font-bold shadow-lg shadow-primary/20 transition-colors">
                                    <span class="material-symbols-outlined text-[18px]">send</span>
                                    Publicar
                                </button>
                            </div>
                        </div>
                        </section>
                    </div>

                    <aside id="detail-side-panel" class="flex flex-col gap-6">
                        <section id="assignee-section" class="hidden bg-white dark:bg-surface-darker border border-border-dark rounded-xl p-5 shadow-xl">
                            <div class="flex items-center justify-between gap-2 mb-3">
                                <h3 class="text-gray-900 dark:text-white text-lg font-bold flex items-center gap-2">
                                    <span class="material-symbols-outlined text-primary">person</span>
                                    Asignaci&#xF3;n
                                </h3>
                                <span id="assignee-save" class="text-xs text-text-muted"></span>
                            </div>

                            <div class="flex items-center justify-between gap-3">
                                <div class="flex items-center gap-3 min-w-0">
                                    <div id="assignee-avatar" class="w-10 h-10 rounded-full bg-primary/20 text-primary border border-primary/30 flex items-center justify-center font-bold text-sm overflow-hidden bg-center bg-cover bg-no-repeat"></div>
                                    <div class="min-w-0">
                                        <p class="text-xs font-bold uppercase tracking-wide text-text-muted">Asignado a</p>
                                        <p id="assignee-name" class="text-gray-900 dark:text-white font-semibold truncate">Sin asignar</p>
                                        <p id="assignee-dept" class="text-text-muted text-xs truncate"></p>
                                    </div>
                                </div>

                                <div class="relative flex-shrink-0">
                                    <button id="assignee-toggle" type="button" class="inline-flex items-center gap-2 h-9 px-3 rounded-lg border border-border-dark bg-white dark:bg-surface-dark text-text-muted hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-white/5 transition-colors text-sm font-semibold">
                                        <span class="material-symbols-outlined text-[18px]">swap_horiz</span>
                                        Cambiar
                                    </button>
                                    <div id="assignee-menu" class="action-menu hidden absolute right-0 top-full mt-2 w-72 bg-white dark:bg-surface-dark border border-border-dark rounded-lg shadow-xl overflow-y-auto max-h-80 z-50"></div>
                                </div>
                            </div>
                        </section>

                        <section id="status-section" class="hidden bg-white dark:bg-surface-darker border border-border-dark rounded-xl p-5 shadow-xl">
                            <div class="flex items-center justify-between gap-2 mb-4">
                                <h3 class="text-gray-900 dark:text-white text-lg font-bold flex items-center gap-2">
                                    <span class="material-symbols-outlined text-primary">timeline</span>
                                    Estado
                                </h3>
                                <div class="flex items-center gap-2">
                                    <span id="status-save" class="text-xs text-text-muted"></span>
                                    <span id="status-chip" class="text-xs font-bold px-2.5 py-1 rounded-md border uppercase tracking-wide">-</span>
                                </div>
                            </div>

                            <div class="w-full overflow-x-auto pb-1">
                                <div class="min-w-[260px] flex items-center justify-between gap-2 relative px-1">
                                    <div class="absolute top-1/2 left-0 w-full h-1 bg-gray-200 dark:bg-surface-dark -z-10 rounded-full transform -translate-y-1/2"></div>
                                    <div id="status-progress" class="absolute top-1/2 left-0 h-1 -z-0 rounded-full transform -translate-y-1/2"></div>

                                    <button type="button" class="flex flex-col items-center gap-1 group cursor-pointer" data-status-step="Pendiente">
                                        <div data-status-circle class="size-7 rounded-full bg-white dark:bg-surface-dark border-2 border-border-dark text-text-muted flex items-center justify-center z-10">
                                            <span data-status-icon class="material-symbols-outlined text-[11px]">schedule</span>
                                        </div>
                                        <span data-status-label class="text-text-muted text-[10px] font-bold uppercase tracking-wider">Pendiente</span>
                                    </button>

                                    <button type="button" class="flex flex-col items-center gap-1 group cursor-pointer" data-status-step="En proceso">
                                        <div data-status-circle class="size-7 rounded-full bg-white dark:bg-surface-dark border-2 border-border-dark text-text-muted flex items-center justify-center z-10">
                                            <span data-status-icon class="material-symbols-outlined text-[11px]">autorenew</span>
                                        </div>
                                        <span data-status-label class="text-text-muted text-[10px] font-bold uppercase tracking-wider">En proceso</span>
                                    </button>

                                    <button type="button" class="flex flex-col items-center gap-1 group cursor-pointer" data-status-step="Finalizado">
                                        <div data-status-circle class="size-7 rounded-full bg-white dark:bg-surface-dark border-2 border-border-dark text-text-muted flex items-center justify-center z-10">
                                            <span data-status-icon class="material-symbols-outlined text-[11px]">check_circle</span>
                                        </div>
                                        <span data-status-label class="text-text-muted text-[10px] font-bold uppercase tracking-wider">Finalizado</span>
                                    </button>
                                </div>
                            </div>

                            <p id="status-helper" class="text-xs text-text-muted mt-2"></p>
                        </section>

                        <section class="bg-white dark:bg-surface-darker border border-border-dark rounded-xl p-5 shadow-xl">
                            <h3 class="text-gray-900 dark:text-white text-lg font-bold flex items-center gap-2 mb-4">
                                <span class="material-symbols-outlined text-primary">tune</span>
                                Detalles
                            </h3>
                            <div class="flex flex-col gap-4">
                                <label class="flex flex-col gap-2 text-sm">
                                    <span class="text-xs font-bold uppercase tracking-wide text-text-muted">⏱️ Tiempo estimado</span>
                                    <div class="flex items-center gap-2">
                                        <input id="estimated-hours-input" type="number" min="0" step="0.5" placeholder="0" class="w-24 h-10 rounded-lg border border-border-dark bg-white dark:bg-background-dark text-gray-900 dark:text-white px-3 text-sm focus:ring-1 focus:ring-primary focus:border-primary/50"/>
                                        <span class="text-sm text-text-muted">horas</span>
                                    </div>
                                </label>
                                <label class="flex flex-col gap-2 text-sm">
                                    <span class="text-xs font-bold uppercase tracking-wide text-text-muted">📊 Tiempo empleado</span>
                                    <input id="time-spent-input" type="text" class="w-full h-10 rounded-lg border border-border-dark bg-white dark:bg-background-dark text-gray-900 dark:text-white px-3 text-sm focus:ring-1 focus:ring-primary focus:border-primary/50" placeholder="Ej: 2h 30m"/>
                                    <div id="time-progress-container" class="hidden mt-2">
                                        <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                                            <div id="time-progress-bar" class="h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                                        </div>
                                        <p id="time-progress-text" class="text-xs text-text-muted mt-1"></p>
                                    </div>
                                </label>
                                <label class="flex flex-col gap-2 text-sm">
                                    <span class="text-xs font-bold uppercase tracking-wide text-text-muted">Fecha</span>
                                    <input id="work-date-input" type="date" class="w-full h-10 rounded-lg border border-border-dark bg-white dark:bg-background-dark text-gray-900 dark:text-white px-3 text-sm focus:ring-1 focus:ring-primary focus:border-primary/50"/>
                                </label>
                                <span id="detail-fields-status" class="text-xs text-text-muted"></span>
                            </div>
                        </section>
                    </aside>
                </div>

                <div id="error-box" class="hidden rounded-lg border border-red-400 bg-red-500/10 text-red-100 px-4 py-3 text-sm"></div>
            </div>
        </main>
    </div>

    <script type="module">
        import { auth, database } from './firebase.js';
        import { ref, get, set, update, push, onValue, serverTimestamp, runTransaction, remove } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js';
        import { onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js';

        const qs = (id) => document.getElementById(id);
        const setText = (id, value) => { const el = qs(id); if (el) el.textContent = value || '-'; };
        const showError = (msg) => { const box = qs('error-box'); if (!box) return; box.classList.remove('hidden'); box.textContent = msg; };

        qs('tamoe-home')?.addEventListener('click', (e) => {
            e.preventDefault();
            const target = `maindashboard.html?r=${Date.now()}`;
            window.top.location.href = target;
        });

        const TYPE_LABELS = { client: 'Cliente', project: 'Proyecto', product: 'Producto', task: 'Tarea', subtask: 'Subtarea' };
        const getAssignmentTitle = (type) => (
            type === 'subtask' ? 'Se te ha asignado la subtarea' : 'Se te ha asignado la tarea'
        );

        const parseClientPath = (pathValue) => {
            const path = String(pathValue || '').trim();
            if (!path) return null;
            const parts = path.split('/').filter(Boolean);
            if (parts[0] !== 'clients') return null;
            const clientId = parts[1] || '';
            if (!clientId) return null;

            const projectIndex = parts.indexOf('projects');
            const projectId = projectIndex >= 0 ? (parts[projectIndex + 1] || '') : '';
            const productIndex = parts.indexOf('products');
            const productId = productIndex >= 0 ? (parts[productIndex + 1] || '') : '';
            const taskIndex = parts.indexOf('tasks');
            const taskId = taskIndex >= 0 ? (parts[taskIndex + 1] || '') : '';
            const subtaskIndex = parts.indexOf('subtasks');
            const subtaskId = subtaskIndex >= 0 ? (parts[subtaskIndex + 1] || '') : '';

            const type = subtaskId
                ? 'subtask'
                : taskId
                    ? 'task'
                    : productId
                        ? 'product'
                        : projectId
                            ? 'project'
                            : 'client';

            return { type, clientId, projectId, productId, taskId, subtaskId, path };
        };

        const stripDiacritics = (textValue) => (
            String(textValue || '')
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
        );

        const buildManagePrefixFromName = (name) => {
            const cleaned = stripDiacritics(String(name || '')).trim();
            if (!cleaned) return 'XX';

            const words = cleaned.split(/\s+/).filter(Boolean);
            const pickFirstAlnum = (word) => {
                const match = String(word).match(/[A-Za-z0-9]/);
                return match ? match[0].toUpperCase() : '';
            };

            if (words.length >= 2) {
                const initials = words.map(pickFirstAlnum).filter(Boolean).join('');
                return initials || 'XX';
            }

            const chars = (words[0].match(/[A-Za-z0-9]/g) || []).join('');
            const prefix = chars.slice(0, 2).toUpperCase();
            return (prefix || 'XX').padEnd(2, 'X');
        };

        const formatManageId = (prefix, number) => {
            const safePrefix = String(prefix || 'XX').toUpperCase();
            const safeNumber = Number.isFinite(Number(number)) ? Number(number) : 0;
            return `${safePrefix}-${String(safeNumber).padStart(3, '0')}`;
        };

        const parseManageNumber = (manageIdValue) => {
            const manageIdText = String(manageIdValue || '');
            const match = manageIdText.match(/-(\d{3,})$/);
            if (!match) return null;
            const num = Number.parseInt(match[1], 10);
            return Number.isFinite(num) ? num : null;
        };

        const getMaxManageNumberForClient = (client) => {
            let max = parseManageNumber(client?.manageId) || 0;
            const projects = client?.projects || {};
            for (const project of Object.values(projects)) {
                if (!project) continue;
                max = Math.max(max, parseManageNumber(project.manageId) || 0);

                const projectTasks = project.tasks || {};
                for (const task of Object.values(projectTasks)) {
                    if (!task) continue;
                    max = Math.max(max, parseManageNumber(task.manageId) || 0);
                    const subtasks = task.subtasks || {};
                    for (const subtask of Object.values(subtasks)) {
                        if (!subtask) continue;
                        max = Math.max(max, parseManageNumber(subtask.manageId) || 0);
                    }
                }

                const products = project.products || {};
                for (const product of Object.values(products)) {
                    if (!product) continue;
                    max = Math.max(max, parseManageNumber(product.manageId) || 0);
                    const productTasks = product.tasks || {};
                    for (const task of Object.values(productTasks)) {
                        if (!task) continue;
                        max = Math.max(max, parseManageNumber(task.manageId) || 0);
                        const subtasks = task.subtasks || {};
                        for (const subtask of Object.values(subtasks)) {
                            if (!subtask) continue;
                            max = Math.max(max, parseManageNumber(subtask.manageId) || 0);
                        }
                    }
                }
            }
            return max;
        };

        const ensureClientManageConfig = async (clientIdValue) => {
            const clientId = String(clientIdValue || '').trim();
            if (!clientId) throw new Error('CLIENT_ID_REQUIRED');

            const snap = await get(ref(database, `clients/${clientId}`));
            const client = snap.val() || {};

            const prefix = String(client.managePrefix || '').trim() || buildManagePrefixFromName(client.name);
            const maxNumber = getMaxManageNumberForClient(client);
            const desiredNext = Math.max(2, maxNumber + 1);

            const updatesPayload = {};
            if (!client.managePrefix) updatesPayload.managePrefix = prefix;
            if (!client.manageId) updatesPayload.manageId = formatManageId(prefix, 1);
            if (typeof client.manageNextNumber !== 'number' || !Number.isFinite(client.manageNextNumber) || client.manageNextNumber < desiredNext) {
                updatesPayload.manageNextNumber = desiredNext;
            }

            if (Object.keys(updatesPayload).length > 0) {
                await update(ref(database, `clients/${clientId}`), updatesPayload);
                Object.assign(client, updatesPayload);
            }

            return { client, prefix };
        };

        const allocateNextManageId = async (clientIdValue) => {
            const clientId = String(clientIdValue || '').trim();
            const { client, prefix } = await ensureClientManageConfig(clientId);

            const nextRef = ref(database, `clients/${clientId}/manageNextNumber`);
            const result = await runTransaction(nextRef, (current) => {
                const safeCurrent = (typeof current === 'number' && Number.isFinite(current) && current >= 2)
                    ? current
                    : (typeof client.manageNextNumber === 'number' && Number.isFinite(client.manageNextNumber) && client.manageNextNumber >= 2 ? client.manageNextNumber : 2);
                return safeCurrent + 1;
            });

            if (!result.committed) throw new Error('No se pudo reservar un manageId.');
            const storedNext = result.snapshot.val();
            const allocatedNumber = storedNext - 1;
            client.manageNextNumber = storedNext;
            return formatManageId(prefix, allocatedNumber);
        };

        const QC_TASK_TEMPLATE = 'qc_review';
        const QC_TASK_NAME = '? Revisi\u00F3n de Control de Calidad';

        const isQualityControlTask = (task) => task?.automation?.template === QC_TASK_TEMPLATE;

        const fetchTasksObject = async (tasksPathValue) => {
            const tasksPath = String(tasksPathValue || '').trim();
            if (!tasksPath) return {};
            try {
                const snap = await get(ref(database, tasksPath));
                return snap.val() || {};
            } catch (e) {
                console.warn('No se pudo leer tareas para automatizaci\u00F3n:', e);
                return {};
            }
        };

        const qcTaskExistsForSource = (tasksObject, sourcePathValue) => {
            const sourcePath = String(sourcePathValue || '').trim();
            if (!sourcePath) return false;
            return Object.values(tasksObject || {}).some((task) => (
                task
                && task.automation?.template === QC_TASK_TEMPLATE
                && String(task.automation?.sourcePath || '') === sourcePath
            ));
        };

        const ensureQualityControlTask = async ({ clientId, tasksPath, sourcePath, sourceType, sourceName, sourceManageId }) => {
            const safeClientId = String(clientId || '').trim();
            const safeTasksPath = String(tasksPath || '').trim();
            const safeSourcePath = String(sourcePath || '').trim();
            if (!safeClientId || !safeTasksPath || !safeSourcePath) return null;

            const existingTasks = await fetchTasksObject(safeTasksPath);
            if (qcTaskExistsForSource(existingTasks, safeSourcePath)) return null;

            const manageIdValue = await allocateNextManageId(safeClientId);
            const newTaskRef = push(ref(database, safeTasksPath));
            const taskId = newTaskRef.key;

            const taskData = {
                name: QC_TASK_NAME,
                status: 'Pendiente',
                assigneeUid: '',
                createdAt: new Date().toISOString(),
                taskId,
                manageId: manageIdValue,
                automation: {
                    template: QC_TASK_TEMPLATE,
                    sourcePath: safeSourcePath,
                    sourceType: String(sourceType || '').trim(),
                    sourceName: String(sourceName || '').trim(),
                    sourceManageId: String(sourceManageId || '').trim(),
                    createdByUid: currentUser?.uid || '',
                    createdAt: new Date().toISOString(),
                },
            };

            await update(newTaskRef, taskData);

            const sourceLabel = TYPE_LABELS[sourceType] || 'Elemento';
            const sourceTitle = String(sourceName || '').trim() || sourceLabel;
            try {
                await push(ref(database, `clients/${safeClientId}/activity_logs`), {
                    actorUid: currentUser.uid,
                    actorName: getCurrentDisplayName(),
                    description: `Cre\u00F3 tarea autom\u00E1tica \"${QC_TASK_NAME}\" para ${sourceLabel} \"${sourceTitle}\".`,
                    timestamp: serverTimestamp(),
                    action: 'automation_qc',
                    path: `${safeTasksPath}/${taskId}`,
                    entityType: 'task',
                    sourcePath: safeSourcePath
                });
            } catch (e) {
                console.warn('No se pudo registrar el log de actividad:', e);
            }

            return taskData;
        };

        const maybeCascadeFinalizeProduct = async ({ clientId, projectId, productId }) => {
            const safeClientId = String(clientId || '').trim();
            const safeProjectId = String(projectId || '').trim();
            const safeProductId = String(productId || '').trim();
            if (!safeClientId || !safeProjectId || !safeProductId) return;

            const productTasksPath = `clients/${safeClientId}/projects/${safeProjectId}/products/${safeProductId}/tasks`;
            const tasksObject = await fetchTasksObject(productTasksPath);
            const tasks = Object.values(tasksObject || {}).filter(Boolean);
            if (!tasks.length) return;

            const allFinalized = tasks.every(t => normalizeStatus(t.status) === 'Finalizado');
            if (!allFinalized) return;

            const productPath = `clients/${safeClientId}/projects/${safeProjectId}/products/${safeProductId}`;
            try {
                const snap = await get(ref(database, productPath));
                const currentStatus = normalizeStatus(snap.val()?.status);
                if (currentStatus === 'Finalizado') return;
            } catch (e) {
                console.warn('No se pudo leer el estado del producto para cierre en cascada:', e);
            }

            await updateStatusAtPath(productPath, 'Finalizado');
        };

        let manageId = null;
        let loadedClients = [];
        let currentResult = null;
        let currentItemPath = null;
        let commentsUnsubscribe = null;
        let currentUser = null;
        let currentUserProfile = null;

        const descriptionInput = qs('description-input');
        const descriptionView = qs('description-view');
        const descriptionStatus = qs('description-status');
        const saveDescriptionButton = qs('save-description');
        const editDescriptionButton = qs('edit-description');
        const activitiesList = qs('activities-list');
        const commentsList = qs('comments-list');
        const commentInput = qs('comment-input');
        const commentButton = qs('comment-submit');
        const commentHelper = qs('comment-helper');
        const commentCount = qs('comment-count');
        const headerUserAvatar = qs('header-user-avatar');
        const headerUserName = qs('header-user-name');
        const headerUserDept = qs('header-user-dept');
        const commentButtonDefaultHtml = commentButton ? commentButton.innerHTML : 'Publicar';
        const statusSection = qs('status-section');
        const statusSave = qs('status-save');
        const statusChip = qs('status-chip');
        const statusProgress = qs('status-progress');
        const statusHelper = qs('status-helper');
        const statusStepButtons = Array.from(document.querySelectorAll('[data-status-step]'));
        const assigneeSection = qs('assignee-section');
        const assigneeSave = qs('assignee-save');
        const assigneeAvatar = qs('assignee-avatar');
        const assigneeName = qs('assignee-name');
        const assigneeDept = qs('assignee-dept');
        const assigneeToggle = qs('assignee-toggle');
        const assigneeMenu = qs('assignee-menu');
        const estimatedHoursInput = qs('estimated-hours-input');
        const timeSpentInput = qs('time-spent-input');
        const workDateInput = qs('work-date-input');
        const detailFieldsStatus = qs('detail-fields-status');

        let descriptionEditing = false;

        const setDescriptionView = (textValue) => {
            if (!descriptionView) return;
            const text = String(textValue || '').trim();
            if (text) {
                descriptionView.textContent = text;
                descriptionView.classList.remove('text-text-muted');
            } else {
                descriptionView.textContent = 'Sin descripci\u00F3n';
                descriptionView.classList.add('text-text-muted');
            }
        };

        const setDescriptionEditing = (isEditing) => {
            descriptionEditing = Boolean(isEditing);
            descriptionInput?.classList.toggle('hidden', !descriptionEditing);
            descriptionView?.classList.toggle('hidden', descriptionEditing);
            saveDescriptionButton?.classList.toggle('hidden', !descriptionEditing);
            if (descriptionEditing) {
                setTimeout(() => descriptionInput?.focus(), 0);
            }
        };

        const STATUS_STEPS = ['Pendiente', 'En proceso', 'Finalizado'];
        const STATUS_TYPES = new Set(['project', 'product', 'task', 'subtask']);
        const ASSIGNEE_TYPES = new Set(['task', 'subtask']);
        const STATUS_ICONS = {
            'Pendiente': 'schedule',
            'En proceso': 'autorenew',
            'Finalizado': 'check_circle'
        };
        const STATUS_STYLES = {
            'Pendiente': {
                chip: 'bg-slate-500/15 text-slate-200 border-slate-500/30',
                progress: 'bg-slate-500',
                fill: 'bg-slate-500',
                ring: 'ring-slate-500/20',
                border: 'border-slate-400',
                label: 'text-slate-300'
            },
            'En proceso': {
                chip: 'bg-blue-500/15 text-blue-200 border-blue-500/30',
                progress: 'bg-blue-500',
                fill: 'bg-blue-500',
                ring: 'ring-blue-500/20',
                border: 'border-blue-400',
                label: 'text-blue-300'
            },
            'Finalizado': {
                chip: 'bg-emerald-500/15 text-emerald-200 border-emerald-500/30',
                progress: 'bg-emerald-500',
                fill: 'bg-emerald-500',
                ring: 'ring-emerald-500/20',
                border: 'border-emerald-400',
                label: 'text-emerald-300'
            }
        };

        let currentItemType = null;
        let currentItemStatus = 'Pendiente';
        let statusSaving = false;
        let currentAssigneeUid = '';
        let assigneeSaving = false;
        let usersByUid = {};
        let usersUnsubscribe = null;
        let detailFieldsSaving = false;
        let detailFieldsSnapshot = { estimatedHours: '', timeSpent: '', workDate: '' };

        const getManageIdFromUrl = () => {
            const params = new URLSearchParams(window.location.search);
            const mid = params.get('mid');
            if (mid) return mid.toUpperCase();
            const parts = window.location.pathname.split('/').filter(Boolean);
            const last = parts[parts.length - 1];
            if (last && /[A-Za-z0-9]{2,}-\d{3,}/.test(last)) return last.toUpperCase();
            return null;
        };

        manageId = getManageIdFromUrl();
        if (manageId && window.top === window.self && window.location.pathname.indexOf(manageId) === -1) {
            window.history.replaceState({}, '', `/${manageId}`);
        }

        const formatDate = (iso) => {
            if (!iso) return '-';
            const d = new Date(iso);
            if (Number.isNaN(d.getTime())) return '-';
            return d.toLocaleString('es-ES', { dateStyle: 'medium', timeStyle: 'short' });
        };

        const normalizeStatus = (value) => {
            const raw = String(value || '').trim().toLowerCase();
            if (!raw) return 'Pendiente';
            if (raw === 'pendiente') return 'Pendiente';
            if (raw === 'en proceso' || raw === 'enproceso' || raw === 'en_proceso') return 'En proceso';
            if (raw === 'finalizado' || raw === 'finalizada') return 'Finalizado';
            return 'Pendiente';
        };

        const getInitials = (value) => {
            const text = String(value || '').trim();
            if (!text) return '?';
            const parts = text.split(/\s+/).filter(Boolean);
            if (parts.length >= 2) {
                const firstName = parts[0];
                const firstSurname = parts.length >= 3 ? parts[parts.length - 2] : parts[1];
                return `${firstName[0] || ''}${firstSurname[0] || ''}`.toUpperCase() || '?';
            }
            if (parts[0].length >= 2) return parts[0].slice(0, 2).toUpperCase();
            return parts[0][0].toUpperCase();
        };

        const stripWrappingQuotes = (value) => {
            let text = String(value ?? '').trim();
            if (!text) return '';
            const pairs = { '"': '"', "'": "'", '\u201C': '\u201D', '\u2018': '\u2019', '\u00AB': '\u00BB' };
            while (text.length >= 2) {
                const first = text[0];
                const last = text[text.length - 1];
                if (pairs[first] === last) text = text.slice(1, -1).trim();
                else break;
            }
            return text;
        };

        const getCurrentDisplayName = () => (
            stripWrappingQuotes(
                currentUserProfile?.username
                || currentUser?.displayName
                || currentUser?.email
                || 'Invitado'
            )
        );

        const getCurrentDepartment = () => (
            currentUserProfile?.department
            || ''
        );

        const getCurrentPhotoUrl = () => (
            currentUserProfile?.profile_picture
            || currentUser?.photoURL
            || ''
        );

        const getUserDisplayNameByUid = (uid) => {
            const safeUid = String(uid || '').trim();
            if (!safeUid) return '';
            const user = usersByUid?.[safeUid];
            const candidate = user?.username || user?.email || safeUid;
            return stripWrappingQuotes(candidate) || safeUid;
        };

        const getUserDepartmentByUid = (uid) => {
            const safeUid = String(uid || '').trim();
            if (!safeUid) return '';
            const user = usersByUid?.[safeUid];
            return user?.department || '';
        };

        const getUserPhotoByUid = (uid) => {
            const safeUid = String(uid || '').trim();
            if (!safeUid) return '';
            const user = usersByUid?.[safeUid];
            return user?.profile_picture || '';
        };

        const closeAllActionMenus = (exceptMenu = null) => {
            document.querySelectorAll('.action-menu').forEach(menu => {
                if (menu !== exceptMenu) menu.classList.add('hidden');
            });
        };

        const renderAvatar = (el, name, photoUrl) => {
            if (!el) return;
            const photo = String(photoUrl || '').trim();
            const hasPhoto = Boolean(photo);
            el.style.backgroundImage = hasPhoto ? `url(${JSON.stringify(photo)})` : '';
            el.textContent = hasPhoto ? '' : getInitials(name);
            el.setAttribute('aria-label', name || 'Usuario');
        };

        const updateHeaderUser = () => {
            const name = getCurrentDisplayName();
            const dept = getCurrentDepartment();
            const photo = getCurrentPhotoUrl();
            if (headerUserName) headerUserName.textContent = name;
            if (headerUserDept) headerUserDept.textContent = dept;
            renderAvatar(headerUserAvatar, name, photo);
        };

        const renderStatusFlow = () => {
            if (!statusSection) return;

            const enabledForType = STATUS_TYPES.has(currentItemType);
            statusSection.classList.toggle('hidden', !enabledForType);
            if (!enabledForType) return;

            const status = normalizeStatus(currentItemStatus);
            currentItemStatus = status;
            const activeIndex = STATUS_STEPS.indexOf(status);
            const style = STATUS_STYLES[status] || STATUS_STYLES['Pendiente'];

            if (statusChip) {
                statusChip.textContent = status;
                statusChip.className = `text-xs font-bold px-2.5 py-1 rounded-md border uppercase tracking-wide ${style.chip}`;
            }

            if (statusProgress) {
                const width = activeIndex <= 0 ? 0 : activeIndex === 1 ? 50 : 100;
                statusProgress.style.width = `${width}%`;
                statusProgress.className = `absolute top-1/2 left-0 h-1 -z-0 rounded-full transform -translate-y-1/2 ${style.progress} transition-all duration-300`;
            }

            statusStepButtons.forEach(btn => {
                const stepStatus = btn.dataset.statusStep;
                const stepIndex = STATUS_STEPS.indexOf(stepStatus);
                if (stepIndex === -1) return;

                const isCompleted = stepIndex < activeIndex;
                const isActive = stepIndex === activeIndex;

                const circle = btn.querySelector('[data-status-circle]');
                const icon = btn.querySelector('[data-status-icon]');
                const label = btn.querySelector('[data-status-label]');

                if (icon) {
                    icon.textContent = isCompleted ? 'check' : (STATUS_ICONS[stepStatus] || 'circle');
                }

                if (circle) {
                    if (isActive) {
                        circle.className = `size-8 rounded-full ${style.fill} text-white flex items-center justify-center z-10 ring-2 ${style.ring} shadow-lg transition-all`;
                    } else if (isCompleted) {
                        circle.className = `size-7 rounded-full bg-white dark:bg-surface-dark border-2 ${style.border} ${style.label} flex items-center justify-center z-10 transition-all`;
                    } else {
                        circle.className = 'size-7 rounded-full bg-white dark:bg-surface-dark border-2 border-border-dark text-text-muted flex items-center justify-center z-10 opacity-60 transition-all';
                    }
                }

                if (label) {
                    if (isActive || isCompleted) {
                        label.className = `${style.label} text-[10px] font-bold uppercase tracking-wider`;
                    } else {
                        label.className = 'text-text-muted text-[10px] font-bold uppercase tracking-wider opacity-60';
                    }
                }
            });
        };

        const saveStatus = async (nextStatus) => {
            if (!STATUS_TYPES.has(currentItemType)) return;
            if (!currentUser) {
                alert('Debes iniciar sesi\u00F3n para cambiar el estado.');
                return;
            }
            if (!currentItemPath) return;

            const status = normalizeStatus(nextStatus);
            if (status === normalizeStatus(currentItemStatus)) return;

            statusSaving = true;
            if (statusSave) statusSave.textContent = 'Guardando...';
            updateAuthUI();

            try {
                await update(ref(database, currentItemPath), { status });
                currentItemStatus = status;
                renderStatusFlow();
                if (statusSave) {
                    statusSave.textContent = 'Guardado';
                    setTimeout(() => {
                        if (statusSave) statusSave.textContent = '';
                    }, 1500);
                }
            } catch (err) {
                console.error(err);
                if (statusSave) statusSave.textContent = 'No se pudo guardar';
                showError(err.message || 'No se pudo actualizar el estado.');
            } finally {
                statusSaving = false;
                updateAuthUI();
            }
        };

        const subscribeUsers = () => {
            if (usersUnsubscribe) usersUnsubscribe();
            if (!currentUser) return;
            usersUnsubscribe = onValue(ref(database, 'users'), (snapshot) => {
                usersByUid = snapshot.val() || {};
                renderAssigneeSection();
                if (currentResult) renderActivities(currentResult);
            }, (error) => {
                console.warn('No se pudo cargar la lista de usuarios', error);
            });
        };

        const renderAssigneeSection = () => {
            if (!assigneeSection) return;
            const enabledForType = ASSIGNEE_TYPES.has(currentItemType);
            assigneeSection.classList.toggle('hidden', !enabledForType);
            if (!enabledForType) return;

            const uid = String(currentAssigneeUid || '').trim();
            if (!uid) {
                if (assigneeName) assigneeName.textContent = 'Sin asignar';
                if (assigneeDept) assigneeDept.textContent = '';
                if (assigneeAvatar) {
                    assigneeAvatar.style.backgroundImage = '';
                    assigneeAvatar.textContent = '\u2014';
                    assigneeAvatar.setAttribute('aria-label', 'Sin asignar');
                }
                return;
            }

            const name = getUserDisplayNameByUid(uid) || uid;
            const dept = getUserDepartmentByUid(uid);
            const photo = getUserPhotoByUid(uid);
            if (assigneeName) assigneeName.textContent = name;
            if (assigneeDept) assigneeDept.textContent = dept || '';
            renderAvatar(assigneeAvatar, name, photo);
        };

        // Parse time format "2h 30m" to hours
        const parseTimeToHours = (timeString) => {
            const str = String(timeString || '').trim().toLowerCase();
            if (!str) return 0;

            let totalHours = 0;
            const hoursMatch = str.match(/(\d+\.?\d*)\s*h/);
            const minutesMatch = str.match(/(\d+\.?\d*)\s*m/);

            if (hoursMatch) totalHours += parseFloat(hoursMatch[1]);
            if (minutesMatch) totalHours += parseFloat(minutesMatch[1]) / 60;

            return totalHours;
        };

        // Calculate total time recursively for all children
        const calculateTotalTimeSpent = (item, type) => {
            let total = 0;

            switch(type) {
                case 'client':
                    if (item.projects) {
                        Object.values(item.projects).forEach(project => {
                            total += calculateTotalTimeSpent(project, 'project');
                        });
                    }
                    break;

                case 'project':
                    if (item.products) {
                        Object.values(item.products).forEach(product => {
                            total += calculateTotalTimeSpent(product, 'product');
                        });
                    }
                    if (item.tasks) {
                        Object.values(item.tasks).forEach(task => {
                            total += calculateTotalTimeSpent(task, 'task');
                        });
                    }
                    break;

                case 'product':
                    if (item.tasks) {
                        Object.values(item.tasks).forEach(task => {
                            total += calculateTotalTimeSpent(task, 'task');
                        });
                    }
                    break;

                case 'task':
                    if (item.subtasks && Object.keys(item.subtasks).length > 0) {
                        Object.values(item.subtasks).forEach(subtask => {
                            total += parseTimeToHours(subtask.timeSpent);
                        });
                    } else {
                        total = parseTimeToHours(item.timeSpent);
                    }
                    break;

                case 'subtask':
                    total = parseTimeToHours(item.timeSpent);
                    break;
            }

            return total;
        };

        // Check if item has children
        const hasChildren = (item, type) => {
            switch(type) {
                case 'client':
                    return item.projects && Object.keys(item.projects).length > 0;
                case 'project':
                    return (item.products && Object.keys(item.products).length > 0) ||
                           (item.tasks && Object.keys(item.tasks).length > 0);
                case 'product':
                    return item.tasks && Object.keys(item.tasks).length > 0;
                case 'task':
                    return item.subtasks && Object.keys(item.subtasks).length > 0;
                case 'subtask':
                    return false;
                default:
                    return false;
            }
        };

        // Get count text for children
        const getChildrenCountText = (item, type) => {
            switch(type) {
                case 'client':
                    const projectCount = item.projects ? Object.keys(item.projects).length : 0;
                    return `${projectCount} proyecto(s)`;
                case 'project':
                    const productCount = item.products ? Object.keys(item.products).length : 0;
                    const taskCount = item.tasks ? Object.keys(item.tasks).length : 0;
                    if (productCount > 0 && taskCount > 0) {
                        return `${productCount} producto(s) y ${taskCount} tarea(s)`;
                    } else if (productCount > 0) {
                        return `${productCount} producto(s)`;
                    } else {
                        return `${taskCount} tarea(s)`;
                    }
                case 'product':
                    const prodTaskCount = item.tasks ? Object.keys(item.tasks).length : 0;
                    return `${prodTaskCount} tarea(s)`;
                case 'task':
                    const subtaskCount = item.subtasks ? Object.keys(item.subtasks).length : 0;
                    return `${subtaskCount} subtarea(s)`;
                default:
                    return '';
            }
        };

        // Update progress bar
        const updateTimeProgressBar = () => {
            const progressContainer = qs('time-progress-container');
            const progressBar = qs('time-progress-bar');
            const progressText = qs('time-progress-text');

            if (!progressContainer || !progressBar || !progressText) return;

            const estimatedHours = parseFloat(estimatedHoursInput?.value) || 0;
            const actualHours = parseTimeToHours(timeSpentInput?.value);

            if (estimatedHours <= 0) {
                progressContainer.classList.add('hidden');
                return;
            }

            progressContainer.classList.remove('hidden');
            const percent = Math.min((actualHours / estimatedHours) * 100, 100);
            progressBar.style.width = `${percent}%`;

            // Color based on progress
            progressBar.classList.remove('bg-green-500', 'bg-yellow-500', 'bg-red-500');
            if (percent <= 75) {
                progressBar.classList.add('bg-green-500');
            } else if (percent <= 100) {
                progressBar.classList.add('bg-yellow-500');
            } else {
                progressBar.classList.add('bg-red-500');
            }

            progressText.textContent = `${Math.round(percent)}% del tiempo estimado (${actualHours.toFixed(1)}h de ${estimatedHours}h)`;
        };

        const setDetailFields = (item = {}) => {
            const estimatedHours = parseFloat(item.estimatedHours) || 0;
            const timeSpent = String(item.timeSpent || '').trim();
            const workDate = String(item.workDate || '').trim();
            if (estimatedHoursInput) estimatedHoursInput.value = estimatedHours || '';
            if (workDateInput) workDateInput.value = workDate;

            // Check if item has children and should show total time
            const itemHasChildren = hasChildren(item, currentItemType);

            if (itemHasChildren) {
                // Calculate total time from children
                const totalHours = calculateTotalTimeSpent(item, currentItemType);
                const childrenText = getChildrenCountText(item, currentItemType);

                // Show as read-only with total
                if (timeSpentInput) {
                    timeSpentInput.value = `${totalHours.toFixed(1)}h (suma de ${childrenText})`;
                    timeSpentInput.disabled = true;
                    timeSpentInput.classList.add('opacity-75', 'cursor-not-allowed');
                    timeSpentInput.style.fontWeight = '600';
                }
                detailFieldsSnapshot = { estimatedHours: String(estimatedHours), timeSpent: `${totalHours.toFixed(1)}h`, workDate };
            } else {
                // Show as editable
                if (timeSpentInput) {
                    timeSpentInput.value = timeSpent;
                    timeSpentInput.style.fontWeight = 'normal';
                }
                detailFieldsSnapshot = { estimatedHours: String(estimatedHours), timeSpent, workDate };
            }

            if (detailFieldsStatus) detailFieldsStatus.textContent = '';
            updateTimeProgressBar();
        };

        const saveDetailFields = async () => {
            if (!currentUser) {
                alert('Debes iniciar sesi\u00F3n para guardar estos datos.');
                return;
            }
            if (!currentItemPath) return;

            const estimatedHours = parseFloat(estimatedHoursInput?.value) || 0;
            const timeSpent = String(timeSpentInput?.value || '').trim();
            const workDate = String(workDateInput?.value || '').trim();

            const updates = {};
            if (String(estimatedHours) !== detailFieldsSnapshot.estimatedHours) updates.estimatedHours = estimatedHours;
            if (timeSpent !== detailFieldsSnapshot.timeSpent) updates.timeSpent = timeSpent;
            if (workDate !== detailFieldsSnapshot.workDate) updates.workDate = workDate;
            if (!Object.keys(updates).length) return;

            detailFieldsSaving = true;
            if (detailFieldsStatus) detailFieldsStatus.textContent = 'Guardando...';
            updateAuthUI();

            try {
                await update(ref(database, currentItemPath), updates);
                detailFieldsSnapshot = {
                    estimatedHours: String(updates.estimatedHours ?? detailFieldsSnapshot.estimatedHours),
                    timeSpent: updates.timeSpent ?? detailFieldsSnapshot.timeSpent,
                    workDate: updates.workDate ?? detailFieldsSnapshot.workDate
                };
                if (detailFieldsStatus) {
                    detailFieldsStatus.textContent = 'Guardado';
                    setTimeout(() => {
                        if (detailFieldsStatus) detailFieldsStatus.textContent = '';
                    }, 1500);
                }
            } catch (err) {
                console.error(err);
                if (detailFieldsStatus) detailFieldsStatus.textContent = 'No se pudo guardar';
                showError(err.message || 'No se pudieron guardar los datos.');
            } finally {
                detailFieldsSaving = false;
                updateAuthUI();
            }
        };

        const buildAssigneeMenu = () => {
            if (!assigneeMenu) return;
            assigneeMenu.innerHTML = '';

            const makeOption = ({ uid, name, dept, photo }) => {
                const optBtn = document.createElement('button');
                optBtn.type = 'button';
                optBtn.className = 'w-full flex items-center justify-between gap-3 px-4 py-2 text-sm text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-white/10 text-left';
                optBtn.dataset.uid = uid;

                const left = document.createElement('div');
                left.className = 'flex items-center gap-3 min-w-0';

                const a = document.createElement('span');
                a.className = 'w-8 h-8 rounded-full bg-primary/15 text-primary border border-primary/20 flex items-center justify-center text-xs font-bold overflow-hidden bg-center bg-cover bg-no-repeat shrink-0';
                if (photo) {
                    a.style.backgroundImage = `url('${photo}')`;
                    a.textContent = '';
                } else {
                    a.style.backgroundImage = '';
                    a.textContent = getInitials(name);
                }

                const txtWrap = document.createElement('div');
                txtWrap.className = 'flex flex-col min-w-0';

                const txt = document.createElement('span');
                txt.className = 'text-sm font-semibold truncate';
                txt.textContent = name;

                const sub = document.createElement('span');
                sub.className = 'text-xs text-text-muted truncate';
                sub.textContent = dept || '';

                txtWrap.append(txt, sub);
                left.append(a, txtWrap);

                const check = document.createElement('span');
                check.className = 'material-symbols-outlined text-[18px] text-text-muted opacity-0';
                check.textContent = 'check';

                optBtn.append(left, check);
                return optBtn;
            };

            const noneOpt = makeOption({ uid: '', name: 'Sin asignar', dept: '', photo: '' });
            const noneAvatar = noneOpt.querySelector('.w-8');
            if (noneAvatar) {
                noneAvatar.className = 'w-8 h-8 rounded-full bg-white/10 text-text-muted border border-border-dark flex items-center justify-center text-xs font-bold shrink-0';
                noneAvatar.textContent = '\u2014';
            }
            assigneeMenu.appendChild(noneOpt);

            const users = Object.entries(usersByUid || {})
                .map(([uid, user]) => ({ uid, ...user }))
                .filter(entry => entry.uid);

            users.sort((a, b) => (a.username || a.email || '').localeCompare(b.username || b.email || ''));

            users.forEach(user => {
                assigneeMenu.appendChild(makeOption({
                    uid: user.uid,
                    name: user.username || user.email || user.uid,
                    dept: user.department || '',
                    photo: user.profile_picture || ''
                }));
            });

            const current = String(currentAssigneeUid || '').trim();
            Array.from(assigneeMenu.querySelectorAll('button[data-uid]')).forEach((btn) => {
                const isActive = String(btn.dataset.uid || '') === current;
                const check = btn.querySelector('.material-symbols-outlined');
                if (check) check.classList.toggle('opacity-0', !isActive);
            });
        };

        const positionAssigneeMenu = () => {
            if (!assigneeToggle || !assigneeMenu) return;
            const wrapper = assigneeToggle.parentElement;
            if (!wrapper) return;

            const findClippingContainer = () => {
                let node = wrapper.parentElement;
                while (node && node !== document.body && node !== document.documentElement) {
                    const style = window.getComputedStyle(node);
                    const overflowY = style.overflowY;
                    const overflowX = style.overflowX;
                    if (
                        ['auto', 'scroll', 'hidden', 'clip'].includes(overflowY) ||
                        ['auto', 'scroll', 'hidden', 'clip'].includes(overflowX)
                    ) {
                        return node;
                    }
                    node = node.parentElement;
                }
                return document.documentElement;
            };

            const clipping = findClippingContainer();
            const clipRect = clipping.getBoundingClientRect();
            const btnRect = assigneeToggle.getBoundingClientRect();
            const padding = 8;

            assigneeMenu.style.maxHeight = '';

            const wasHidden = assigneeMenu.classList.contains('hidden');
            if (wasHidden) {
                assigneeMenu.classList.remove('hidden');
                assigneeMenu.style.visibility = 'hidden';
            }

            const menuRect = assigneeMenu.getBoundingClientRect();
            const menuHeight = menuRect.height || 220;

            const availableBelow = clipRect.bottom - btnRect.bottom;
            const availableAbove = btnRect.top - clipRect.top;
            const shouldOpenUp = availableBelow < (menuHeight + padding) && availableAbove > availableBelow;

            assigneeMenu.classList.remove('top-full', 'mt-2', 'bottom-full', 'mb-2');
            if (shouldOpenUp) {
                assigneeMenu.classList.add('bottom-full', 'mb-2');
                const maxHeight = Math.max(160, Math.floor(availableAbove - padding));
                assigneeMenu.style.maxHeight = `${maxHeight}px`;
            } else {
                assigneeMenu.classList.add('top-full', 'mt-2');
                const maxHeight = Math.max(160, Math.floor(availableBelow - padding));
                assigneeMenu.style.maxHeight = `${maxHeight}px`;
            }

            if (wasHidden) {
                assigneeMenu.style.visibility = '';
                assigneeMenu.classList.add('hidden');
            }
        };

        const saveAssignee = async (nextUid) => {
            if (!ASSIGNEE_TYPES.has(currentItemType)) return;
            if (!currentUser) {
                alert('Debes iniciar sesi\u00F3n para asignar.');
                return;
            }
            if (!currentItemPath) return;

            const uid = String(nextUid || '').trim();
            if (uid === String(currentAssigneeUid || '').trim()) return;

            assigneeSaving = true;
            if (assigneeSave) assigneeSave.textContent = 'Guardando...';
            updateAuthUI();

            try {
                await update(ref(database, currentItemPath), { assigneeUid: uid });
                currentAssigneeUid = uid;
                renderAssigneeSection();
                if (assigneeSave) {
                    assigneeSave.textContent = 'Guardado';
                    setTimeout(() => {
                        if (assigneeSave) assigneeSave.textContent = '';
                    }, 1500);
                }
            } catch (err) {
                console.error(err);
                if (assigneeSave) assigneeSave.textContent = 'No se pudo guardar';
                showError(err.message || 'No se pudo actualizar la asignacion.');
            } finally {
                assigneeSaving = false;
                updateAuthUI();
            }
        };

        const findByManageId = (clients, mid) => {
            for (const client of clients) {
                const clientNode = { type: 'client', ...client };
                if (client.manageId === mid) {
                    return { type: 'client', item: clientNode, trail: [clientNode], ids: { clientId: client.id } };
                }

                const projects = client.projects || {};
                for (const [projectId, project] of Object.entries(projects)) {
                    const projectNode = { type: 'project', id: projectId, ...project };
                    if (project.manageId === mid) {
                        return { type: 'project', item: projectNode, trail: [clientNode, projectNode], ids: { clientId: client.id, projectId } };
                    }

                    const tasks = project.tasks || {};
                    for (const [taskId, task] of Object.entries(tasks)) {
                        const taskNode = { type: 'task', id: taskId, ...task };
                        if (task.manageId === mid) {
                            return { type: 'task', item: taskNode, trail: [clientNode, projectNode, taskNode], ids: { clientId: client.id, projectId, taskId } };
                        }
                        const subtasks = task.subtasks || {};
                        for (const [subId, sub] of Object.entries(subtasks)) {
                            const subNode = { type: 'subtask', id: subId, ...sub };
                            if (sub.manageId === mid) {
                                return { type: 'subtask', item: subNode, trail: [clientNode, projectNode, taskNode, subNode], ids: { clientId: client.id, projectId, taskId, subtaskId: subId } };
                            }
                        }
                    }

                    const products = project.products || {};
                    for (const [productId, product] of Object.entries(products)) {
                        const productNode = { type: 'product', id: productId, ...product };
                        if (product.manageId === mid) {
                            return { type: 'product', item: productNode, trail: [clientNode, projectNode, productNode], ids: { clientId: client.id, projectId, productId } };
                        }
                        const prodTasks = product.tasks || {};
                        for (const [taskId, task] of Object.entries(prodTasks)) {
                            const taskNode = { type: 'task', id: taskId, ...task };
                            if (task.manageId === mid) {
                                return { type: 'task', item: taskNode, trail: [clientNode, projectNode, productNode, taskNode], ids: { clientId: client.id, projectId, productId, taskId } };
                            }
                            const subtasks = task.subtasks || {};
                            for (const [subId, sub] of Object.entries(subtasks)) {
                                const subNode = { type: 'subtask', id: subId, ...sub };
                                if (sub.manageId === mid) {
                                    return { type: 'subtask', item: subNode, trail: [clientNode, projectNode, productNode, taskNode, subNode], ids: { clientId: client.id, projectId, productId, taskId, subtaskId: subId } };
                                }
                            }
                        }
                    }
                }
            }
            return null;
        };

        const renderBreadcrumb = (trail) => {
            const breadcrumb = qs('breadcrumb');
            if (!breadcrumb) return;
            breadcrumb.innerHTML = '';
            trail.forEach((node, idx) => {
                const label = node.name || TYPE_LABELS[node.type] || 'Detalle';
                const manage = String(node.manageId || '').trim();

                const crumb = document.createElement(manage ? 'a' : 'span');
                crumb.className = manage
                    ? 'text-text-muted hover:text-gray-900 dark:hover:text-white hover:underline transition-colors'
                    : 'text-text-muted';
                crumb.textContent = label;

                if (manage) {
                    crumb.href = `/${encodeURIComponent(manage)}`;
                    crumb.setAttribute('aria-label', `Abrir detalle: ${label}`);
                }
                if (idx === trail.length - 1) {
                crumb.classList.add('text-gray-900', 'dark:text-white');
                    crumb.setAttribute('aria-current', 'page');
                }

                breadcrumb.appendChild(crumb);
                if (idx < trail.length - 1) {
                    const icon = document.createElement('span');
                    icon.className = 'material-symbols-outlined text-text-muted text-[16px]';
                    icon.textContent = 'chevron_right';
                    breadcrumb.appendChild(icon);
                }
            });
        };

        const buildItemPath = (ids, type) => {
            if (!ids?.clientId) return null;
            let path = `clients/${ids.clientId}`;
            if (ids.projectId) path += `/projects/${ids.projectId}`;
            if (type === 'project' && !ids.productId && !ids.taskId) return path;
            if (ids.productId) path += `/products/${ids.productId}`;
            if (type === 'product' && !ids.taskId) return path;
            if (ids.taskId) path += `/tasks/${ids.taskId}`;
            if (type === 'task' && !ids.subtaskId) return path;
            if (ids.subtaskId) path += `/subtasks/${ids.subtaskId}`;
            return path;
        };

        const createStatusDot = (status) => {
            const normalized = normalizeStatus(status);
            const dot = document.createElement('span');
            dot.className = 'inline-block w-2.5 h-2.5 rounded-full ring-1 ring-white/10 shrink-0';
            dot.title = normalized;
            dot.setAttribute('aria-label', normalized);
            if (normalized === 'En proceso') dot.classList.add('bg-blue-400');
            else if (normalized === 'Finalizado') dot.classList.add('bg-emerald-400');
            else dot.classList.add('bg-slate-400');
            return dot;
        };

        const createManageLink = (manageIdValue) => {
            const manageIdText = String(manageIdValue || '').trim();
            const link = document.createElement(manageIdText ? 'a' : 'span');
            // ✅ Añadir margen izquierdo para separarlo del nombre
            link.className = 'text-xs font-mono text-text-muted hover:text-gray-900 dark:hover:text-white hover:underline shrink-0 ml-2';
            if (manageIdText) {
                link.href = `/${encodeURIComponent(manageIdText)}`;
                link.target = '_top';
                link.rel = 'noopener';
                link.textContent = manageIdText;
            } else {
                link.textContent = '';
            }
            return link;
        };

        const editActivityName = async (path, currentName, type) => {
            if (!currentUser) {
                alert('Debes iniciar sesión para editar.');
                return;
            }
            const label = TYPE_LABELS[type] || 'elemento';
            const newName = prompt(`Nuevo nombre de ${label}:`, currentName);
            if (newName === null || newName.trim() === '') return;

            const name = newName.trim();
            try {
                await update(ref(database, path), { name });
                await loadData();
            } catch (err) {
                console.error('Error editando nombre:', err);
                alert(`No se pudo editar: ${err.message || err}`);
            }
        };

        const deleteActivity = async (path, name, type) => {
            if (!currentUser) {
                alert('Debes iniciar sesión para eliminar.');
                return;
            }
            const label = TYPE_LABELS[type] || 'elemento';
            const confirmed = confirm(`¿Estás seguro de que quieres eliminar ${label} "${name}"?\n\nEsta acción no se puede deshacer.`);
            if (!confirmed) return;

            try {
                await remove(ref(database, path));
                await loadData();
            } catch (err) {
                console.error('Error eliminando:', err);
                alert(`No se pudo eliminar: ${err.message || err}`);
            }
        };

        const createSettingsIcon = (path, item, type) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'relative flex-shrink-0';

            const icon = document.createElement('button');
            icon.type = 'button';
            icon.className = 'inline-flex items-center justify-center w-6 h-6 rounded text-text-muted hover:text-primary hover:bg-primary/10 transition-colors';
            icon.innerHTML = '<span class="material-symbols-outlined text-[18px]">more_vert</span>';
            icon.setAttribute('aria-label', 'Opciones');
            icon.title = 'Opciones';

            const menu = document.createElement('div');
            menu.className = 'hidden absolute right-0 top-full mt-2 w-48 bg-white dark:bg-surface-dark border border-border-dark rounded-lg shadow-xl z-50';

            // Opciones del menú
            const options = [];

            // Editar nombre
            const editBtn = document.createElement('button');
            editBtn.type = 'button';
            editBtn.className = 'w-full flex items-center gap-2 px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/5 text-sm text-gray-900 dark:text-white text-left transition-colors';
            editBtn.innerHTML = '<span class="material-symbols-outlined text-[16px]">edit</span><span>Editar nombre</span>';
            editBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                menu.classList.add('hidden');
                await editActivityName(path, item?.name, type);
            });
            options.push(editBtn);

            // Cambiar estado (solo si la actividad tiene estado)
            if (item?.status !== undefined) {
                const statusBtn = document.createElement('button');
                statusBtn.type = 'button';
                statusBtn.className = 'w-full flex items-center gap-2 px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/5 text-sm text-gray-900 dark:text-white text-left transition-colors';
                statusBtn.innerHTML = '<span class="material-symbols-outlined text-[16px]">swap_horiz</span><span>Cambiar estado</span>';
                statusBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    menu.classList.add('hidden');
                    // El control de estado ya existe, solo cerramos el menú
                });
                options.push(statusBtn);
            }

            // Asignar (solo para tareas y subtareas)
            if (type === 'task' || type === 'subtask') {
                const assignBtn = document.createElement('button');
                assignBtn.type = 'button';
                assignBtn.className = 'w-full flex items-center gap-2 px-4 py-2 hover:bg-gray-100 dark:hover:bg-white/5 text-sm text-gray-900 dark:text-white text-left transition-colors';
                assignBtn.innerHTML = '<span class="material-symbols-outlined text-[16px]">person</span><span>Asignar</span>';
                assignBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    menu.classList.add('hidden');
                    // El control de asignación ya existe, solo cerramos el menú
                });
                options.push(assignBtn);
            }

            // Separador
            const separator = document.createElement('hr');
            separator.className = 'border-border-dark';
            options.push(separator);

            // Eliminar
            const deleteBtn = document.createElement('button');
            deleteBtn.type = 'button';
            deleteBtn.className = 'w-full flex items-center gap-2 px-4 py-2 hover:bg-red-50 dark:hover:bg-red-900/20 text-sm text-red-600 dark:text-red-400 text-left transition-colors';
            deleteBtn.innerHTML = '<span class="material-symbols-outlined text-[16px]">delete</span><span>Eliminar</span>';
            deleteBtn.addEventListener('click', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                menu.classList.add('hidden');
                await deleteActivity(path, item?.name, type);
            });
            options.push(deleteBtn);

            // Añadir todas las opciones al menú
            options.forEach(option => menu.appendChild(option));

            // Toggle del menú
            icon.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();

                // Cerrar otros menús abiertos
                document.querySelectorAll('.settings-menu-open').forEach(m => {
                    if (m !== menu) m.classList.add('hidden');
                });

                const isOpen = !menu.classList.contains('hidden');
                if (isOpen) {
                    menu.classList.add('hidden');
                    menu.classList.remove('settings-menu-open');
                } else {
                    menu.classList.remove('hidden');
                    menu.classList.add('settings-menu-open');
                }
            });

            // Cerrar al hacer clic fuera
            const closeOnClickOutside = (e) => {
                if (!wrapper.contains(e.target)) {
                    menu.classList.add('hidden');
                    menu.classList.remove('settings-menu-open');
                }
            };

            // Añadir listener cuando se abre el menú
            icon.addEventListener('click', () => {
                setTimeout(() => {
                    document.addEventListener('click', closeOnClickOutside);
                }, 0);
            });

            // Remover listener cuando se cierra
            menu.addEventListener('transitionend', () => {
                if (menu.classList.contains('hidden')) {
                    document.removeEventListener('click', closeOnClickOutside);
                }
            });

            wrapper.append(icon, menu);
            return wrapper;
        };

        const createAssigneeBadge = (assigneeUid) => {
            const uid = String(assigneeUid || '').trim();
            const badge = document.createElement('span');
            badge.className = 'text-xs text-text-muted truncate max-w-[12rem]';
            if (!uid) {
                badge.textContent = 'Sin asignar';
                return badge;
            }
            const name = getUserDisplayNameByUid(uid) || uid;
            badge.textContent = `Asignado a ${name}`;
            return badge;
        };

        const makeActivityActionButton = ({ label, icon = 'add', onClick }) => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'inline-flex items-center gap-2 h-8 px-3 rounded-md border border-border-dark bg-white dark:bg-surface-dark text-text-muted hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-white/5 transition-colors text-xs font-semibold';
            const iconEl = document.createElement('span');
            iconEl.className = 'material-symbols-outlined text-[16px]';
            iconEl.textContent = icon;
            const text = document.createElement('span');
            text.textContent = label;
            button.append(iconEl, text);
            button.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                onClick?.();
            });
            return button;
        };

        const SORT_OPTIONS = [
            { value: 'created-desc', label: 'Fecha de creación (más reciente)' },
            { value: 'created-asc', label: 'Fecha de creación (más antigua)' },
            { value: 'alpha-asc', label: 'Nombre (A–Z)' },
            { value: 'alpha-desc', label: 'Nombre (Z–A)' },
        ];
        const SORT_VALUES = new Set(SORT_OPTIONS.map(option => option.value));
        const DEFAULT_SORT_MODE = 'created-desc';

        const normalizeSortMode = (value) => (SORT_VALUES.has(value) ? value : DEFAULT_SORT_MODE);

        const parseSortTimestamp = (value) => {
            if (!value) return null;
            if (typeof value === 'number' && Number.isFinite(value)) return value;
            if (typeof value === 'string') {
                const parsed = Date.parse(value);
                return Number.isFinite(parsed) ? parsed : null;
            }
            if (typeof value === 'object') {
                if (typeof value.toMillis === 'function') return value.toMillis();
                if (typeof value.seconds === 'number') return value.seconds * 1000;
                if (typeof value.timestamp === 'number') return value.timestamp;
            }
            return null;
        };

        const compareActivities = (a, b, sortMode) => {
            const mode = normalizeSortMode(sortMode);
            const nameCompare = String(a?.name || '').localeCompare(String(b?.name || ''), 'es', { sensitivity: 'base' });

            if (mode === 'alpha-asc') return nameCompare;
            if (mode === 'alpha-desc') return -nameCompare;

            const timeA = parseSortTimestamp(a?.createdAt);
            const timeB = parseSortTimestamp(b?.createdAt);
            const hasA = Number.isFinite(timeA);
            const hasB = Number.isFinite(timeB);

            if (hasA && hasB) {
                const direction = mode === 'created-asc' ? 1 : -1;
                const timeDiff = (timeA - timeB) * direction;
                if (timeDiff !== 0) return timeDiff;
            } else if (hasA !== hasB) {
                return hasA ? -1 : 1;
            }

            return nameCompare;
        };

        const sortActivities = (items, sortMode) => {
            const list = Array.isArray(items) ? [...items] : [];
            list.sort((a, b) => compareActivities(a, b, sortMode));
            return list;
        };

        const getDetailSortStorageKey = (sectionKey) => `tamoe.detailSortMode.${sectionKey}`;

        const loadDetailSortMode = (sectionKey) => {
            try {
                return normalizeSortMode(localStorage.getItem(getDetailSortStorageKey(sectionKey)));
            } catch (error) {
                return DEFAULT_SORT_MODE;
            }
        };

        const detailSortModes = {
            projects: loadDetailSortMode('projects'),
            projectTasks: loadDetailSortMode('projectTasks'),
            projectProducts: loadDetailSortMode('projectProducts'),
            productTasks: loadDetailSortMode('productTasks'),
            taskSubtasks: loadDetailSortMode('taskSubtasks'),
        };

        const getDetailSortMode = (sectionKey) => normalizeSortMode(detailSortModes[sectionKey]);

        const mapEntriesToItems = (entries) => (
            entries.map(([id, value]) => ({
                id,
                name: value?.name || '',
                createdAt: value?.createdAt || '',
                ref: value,
            }))
        );

        // Guardar estado de todos los <details> abiertos
        const saveDetailsState = () => {
            const openDetails = [];
            const detailsElements = document.querySelectorAll('#activities-list details[open]');

            detailsElements.forEach(details => {
                const summary = details.querySelector('summary');
                if (summary) {
                    const manageLink = summary.querySelector('a[href*="/"]');
                    if (manageLink) {
                        const manageId = manageLink.textContent.trim();
                        if (manageId) {
                            openDetails.push(manageId);
                        }
                    }
                }
            });

            return openDetails;
        };

        // Restaurar estado de <details> abiertos
        const restoreDetailsState = (openManageIds) => {
            if (!openManageIds || openManageIds.length === 0) return;

            setTimeout(() => {
                const detailsElements = document.querySelectorAll('#activities-list details');

                detailsElements.forEach(details => {
                    const summary = details.querySelector('summary');
                    if (summary) {
                        const manageLink = summary.querySelector('a[href*="/"]');
                        if (manageLink) {
                            const manageId = manageLink.textContent.trim();
                            if (openManageIds.includes(manageId)) {
                                details.setAttribute('open', '');
                            }
                        }
                    }
                });
            }, 50);
        };

        const persistDetailSortMode = (sectionKey, mode) => {
            try {
                localStorage.setItem(getDetailSortStorageKey(sectionKey), mode);
            } catch (error) {
                // Ignore storage failures.
            }
        };

        const setDetailSortMode = (sectionKey, nextMode) => {
            const mode = normalizeSortMode(nextMode);
            detailSortModes[sectionKey] = mode;
            persistDetailSortMode(sectionKey, mode);

            if (currentResult) {
                const openDetailsState = saveDetailsState();
                renderActivities(currentResult);
                restoreDetailsState(openDetailsState);
            }
        };

        const createSortSelect = (sectionKey) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'relative flex items-center justify-end';

            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'size-8 rounded-md border border-border-dark bg-white dark:bg-surface-dark text-text-muted hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-white/5 transition-colors flex items-center justify-center';
            button.setAttribute('aria-label', 'Ordenar actividades');
            button.title = 'Ordenar actividades';
            button.innerHTML = '<span class="material-symbols-outlined text-[16px]">sort</span>';

            const menu = document.createElement('div');
            menu.className = 'action-menu hidden absolute right-0 top-full mt-2 w-60 bg-white dark:bg-surface-dark border border-border-dark rounded-lg shadow-xl overflow-hidden z-50 text-gray-900 dark:text-white';

            const updateChecks = () => {
                const current = getDetailSortMode(sectionKey);
                menu.querySelectorAll('button[data-sort]').forEach((btn) => {
                    const isActive = btn.dataset.sort === current;
                    const check = btn.querySelector('.material-symbols-outlined.check');
                    if (check) check.classList.toggle('opacity-0', !isActive);
                });
            };

            SORT_OPTIONS.forEach((option) => {
                const optBtn = document.createElement('button');
                optBtn.type = 'button';
                optBtn.dataset.sort = option.value;
                optBtn.className = 'w-full flex items-center justify-between gap-2 px-4 py-2 text-sm text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-white/10 text-left';
                optBtn.innerHTML = `
                    <span class="inline-flex items-center gap-2">
                        <span class="material-symbols-outlined text-[18px]">sort</span>
                        ${option.label}
                    </span>
                    <span class="material-symbols-outlined check text-[18px] text-text-muted opacity-0">check</span>
                `;
                optBtn.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    menu.classList.add('hidden');
                    setDetailSortMode(sectionKey, option.value);
                    updateChecks();
                });
                menu.appendChild(optBtn);
            });

            menu.addEventListener('click', event => event.stopPropagation());

            button.addEventListener('click', (event) => {
                event.preventDefault();
                event.stopPropagation();
                closeAllActionMenus(menu);
                updateChecks();
                menu.classList.toggle('hidden');
            });

            wrapper.append(button, menu);
            return wrapper;
        };

        const makeGroupHeader = (label, sectionKey, { className = '', labelClass = '' } = {}) => {
            const header = document.createElement('div');
            header.className = `flex items-center justify-between gap-2 ${className}`.trim();

            const title = document.createElement('p');
            title.className = labelClass || 'text-text-muted text-xs font-semibold uppercase tracking-wide px-1';
            title.textContent = label;

            header.append(title, createSortSelect(sectionKey));
            return header;
        };

        const createChildActivity = async ({ label, path, type }) => {
            if (!currentUser) {
                alert('Debes iniciar sesi\u00F3n para crear actividades.');
                return;
            }
            // ✅ USAR MODAL EN LUGAR DE PROMPT
            const name = await openCreateActivityModal(label);
            if (!name) return; // Usuario canceló
            const safePath = String(path || '').trim();
            if (!safePath) return;

            // ✅ GUARDAR ESTADO
            const openDetailsState = saveDetailsState();

            try {
                const manageIdValue = await allocateNextManageId(currentResult?.ids?.clientId || '');
                const newRef = push(ref(database, safePath));
                const now = new Date().toISOString();
                const idField = `${type}Id`;
                const data = {
                    name,
                    status: 'Pendiente',
                    createdAt: now,
                    manageId: manageIdValue,
                    [idField]: newRef.key
                };
                if (type === 'task' || type === 'subtask') {
                    data.assigneeUid = '';
                }
                await set(newRef, data);
                await loadData();

                // ✅ RESTAURAR ESTADO
                restoreDetailsState(openDetailsState);

            } catch (err) {
                console.error('Error creando actividad:', err);
                alert(`No se pudo crear la actividad: ${err.message || err}`);
            }
        };

        const applyStatusChipStyle = (button, labelEl, status) => {
            const normalized = normalizeStatus(status);
            if (labelEl) labelEl.textContent = normalized;
            if (!button) return;
            const style = STATUS_STYLES[normalized]?.chip || STATUS_STYLES['Pendiente']?.chip || 'bg-slate-500/15 text-slate-200 border-slate-500/30';
            button.className = `inline-flex items-center gap-1 text-[11px] font-bold px-2 py-0.5 rounded-full border ${style} hover:brightness-110 transition-colors`;
            button.setAttribute('aria-label', `Estado: ${normalized}`);
            button.title = normalized;
        };

        const updateStatusAtPath = async (path, nextStatus) => {
            if (!currentUser) {
                alert('Debes iniciar sesi\u00F3n para cambiar el estado.');
                throw new Error('AUTH_REQUIRED');
            }
            const parsed = parseClientPath(path);
            let before = null;
            try {
                const snap = await get(ref(database, path));
                before = snap.val();
            } catch (e) {
                before = null;
            }

            const prevStatus = normalizeStatus(before?.status);
            const status = normalizeStatus(nextStatus);
            await update(ref(database, path), { status });

            if (parsed?.clientId && prevStatus !== status) {
                const label = TYPE_LABELS[parsed.type] || 'Elemento';
                const itemName = before?.name || label;
                try {
                    await push(ref(database, `clients/${parsed.clientId}/activity_logs`), {
                        actorUid: currentUser.uid,
                        actorName: getCurrentDisplayName(),
                        description: `Actualiz\u00F3 estado de ${label} \"${itemName}\" de \"${prevStatus}\" a \"${status}\".`,
                        timestamp: serverTimestamp(),
                        action: 'status_update',
                        path,
                        entityType: parsed.type
                    });
                } catch (e) {
                    console.warn('No se pudo registrar el log de actividad:', e);
                }
            }
            try {
                const shouldTriggerFinalization = prevStatus !== 'Finalizado' && status === 'Finalizado';

                if (shouldTriggerFinalization && parsed?.clientId && parsed.projectId) {
                    if (parsed.type === 'task') {
                        if (!isQualityControlTask(before)) {
                            const tasksPath = parsed.productId
                                ? `clients/${parsed.clientId}/projects/${parsed.projectId}/products/${parsed.productId}/tasks`
                                : `clients/${parsed.clientId}/projects/${parsed.projectId}/tasks`;

                            await ensureQualityControlTask({
                                clientId: parsed.clientId,
                                tasksPath,
                                sourcePath: path,
                                sourceType: parsed.type,
                                sourceName: before?.name || 'Tarea',
                                sourceManageId: before?.manageId || ''
                            });
                        }
                    } else if (parsed.type === 'product') {
                        const tasksPath = `clients/${parsed.clientId}/projects/${parsed.projectId}/tasks`;
                        await ensureQualityControlTask({
                            clientId: parsed.clientId,
                            tasksPath,
                            sourcePath: path,
                            sourceType: parsed.type,
                            sourceName: before?.name || 'Producto',
                            sourceManageId: before?.manageId || ''
                        });
                    }
                }

                if (parsed?.type === 'task' && parsed.clientId && parsed.projectId && parsed.productId && status === 'Finalizado') {
                    await maybeCascadeFinalizeProduct({
                        clientId: parsed.clientId,
                        projectId: parsed.projectId,
                        productId: parsed.productId
                    });
                }
            } catch (e) {
                console.warn('Error ejecutando automatizaciones de estado:', e);
            }
            return status;
        };

        const updateAssigneeAtPath = async (path, nextUid) => {
            if (!currentUser) {
                alert('Debes iniciar sesi\u00F3n para asignar.');
                throw new Error('AUTH_REQUIRED');
            }
            const parsed = parseClientPath(path);
            let before = null;
            try {
                const snap = await get(ref(database, path));
                before = snap.val();
            } catch (e) {
                before = null;
            }

            const prevUid = String(before?.assigneeUid || '').trim();
            const uid = String(nextUid || '').trim();
            await update(ref(database, path), { assigneeUid: uid });

            if (parsed?.clientId && prevUid !== uid) {
                const label = TYPE_LABELS[parsed.type] || 'Elemento';
                const itemName = before?.name || label;
                const toName = uid ? (getUserDisplayNameByUid(uid) || uid) : 'Sin asignar';
                try {
                    await push(ref(database, `clients/${parsed.clientId}/activity_logs`), {
                        actorUid: currentUser.uid,
                        actorName: getCurrentDisplayName(),
                        description: `Asign\u00F3 ${label} \"${itemName}\" a ${toName}.`,
                        timestamp: serverTimestamp(),
                        action: 'assignee_update',
                        path,
                        entityType: parsed.type,
                        assigneeUid: uid
                    });
                } catch (e) {
                    console.warn('No se pudo registrar el log de actividad:', e);
                }
            }

            if (uid && prevUid !== uid) {
                try {
                    const itemName = before?.name || 'Tarea';
                    const title = getAssignmentTitle(parsed?.type);
                    await push(ref(database, `notifications/${uid}`), {
                        title,
                        taskName: itemName,
                        manageId: before?.manageId || '',
                        entityType: parsed?.type || '',
                        path,
                        fromUid: currentUser.uid,
                        fromName: getCurrentDisplayName(),
                        read: false,
                        createdAt: serverTimestamp(),
                    });
                } catch (e) {
                    console.warn('No se pudo enviar la notificaci\u00F3n:', e);
                }
            }
            return uid;
        };

        const createAssigneeControl = ({ assigneeUid, onChange }) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'relative flex-shrink-0';

            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'inline-flex items-center justify-between gap-2 text-[11px] font-bold px-2 py-0.5 rounded-full border border-border-dark bg-white/70 dark:bg-white/5 text-text-muted hover:text-gray-900 dark:hover:text-white hover:bg-gray-100 dark:hover:bg-white/10 transition-colors';

            const left = document.createElement('div');
            left.className = 'flex items-center gap-2 min-w-0';

            const avatar = document.createElement('span');
            avatar.className = 'inline-flex items-center justify-center w-5 h-5 rounded-full bg-primary/15 text-primary border border-primary/20 text-[10px] font-bold overflow-hidden bg-center bg-cover bg-no-repeat shrink-0';

            const label = document.createElement('span');
            label.className = 'truncate max-w-[11rem]';

            const caret = document.createElement('span');
            caret.className = 'material-symbols-outlined text-[16px] leading-none opacity-70';
            caret.textContent = 'expand_more';

            left.append(avatar, label);
            button.append(left, caret);

            const applyAssignee = (uidValue) => {
                const uid = String(uidValue || '').trim();
                if (!uid) {
                    avatar.style.backgroundImage = '';
                    avatar.textContent = '-';
                    avatar.classList.remove('text-primary', 'border-primary/20', 'bg-primary/15');
                    avatar.classList.add('text-text-muted', 'border-border-dark', 'bg-white/10');
                    label.textContent = 'Sin asignar';
                    button.title = 'Sin asignar';
                    return;
                }

                const name = getUserDisplayNameByUid(uid) || uid;
                const photo = getUserPhotoByUid(uid);
                if (photo) {
                    avatar.style.backgroundImage = `url('${photo}')`;
                    avatar.textContent = '';
                } else {
                    avatar.style.backgroundImage = '';
                    avatar.textContent = getInitials(name);
                }
                avatar.classList.remove('text-text-muted', 'border-border-dark', 'bg-white/10');
                avatar.classList.add('text-primary', 'border-primary/20', 'bg-primary/15');
                label.textContent = `Asignado a ${name}`;
                button.title = `Asignado a ${name}`;
            };

            applyAssignee(assigneeUid);

            const menu = document.createElement('div');
            menu.className = 'action-menu hidden absolute right-0 w-72 bg-white dark:bg-surface-dark border border-border-dark rounded-lg shadow-xl overflow-x-hidden overflow-y-auto z-50 text-gray-900 dark:text-white';

            const canEdit = Boolean(currentUser) && typeof onChange === 'function';
            button.disabled = !canEdit;
            button.classList.toggle('opacity-60', !canEdit);
            button.classList.toggle('cursor-not-allowed', !canEdit);

            let saving = false;
            const setSaving = (isSaving) => {
                saving = isSaving;
                button.disabled = isSaving || !canEdit;
                button.classList.toggle('opacity-60', button.disabled);
                button.classList.toggle('cursor-not-allowed', button.disabled);
            };

            const makeOption = ({ uid, name, dept, photo }) => {
                const optBtn = document.createElement('button');
                optBtn.type = 'button';
                optBtn.className = 'w-full flex items-center justify-between gap-3 px-4 py-2 text-sm text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-white/10 text-left';
                optBtn.dataset.uid = uid;

                const optLeft = document.createElement('div');
                optLeft.className = 'flex items-center gap-3 min-w-0';

                const a = document.createElement('span');
                a.className = 'w-8 h-8 rounded-full bg-primary/15 text-primary border border-primary/20 flex items-center justify-center text-xs font-bold overflow-hidden bg-center bg-cover bg-no-repeat shrink-0';
                if (photo) {
                    a.style.backgroundImage = `url('${photo}')`;
                    a.textContent = '';
                } else {
                    a.style.backgroundImage = '';
                    a.textContent = getInitials(name);
                }

                const txtWrap = document.createElement('div');
                txtWrap.className = 'flex flex-col min-w-0';

                const txt = document.createElement('span');
                txt.className = 'text-sm font-semibold truncate';
                txt.textContent = name;

                const sub = document.createElement('span');
                sub.className = 'text-xs text-text-muted truncate';
                sub.textContent = dept || '';

                txtWrap.append(txt, sub);
                optLeft.append(a, txtWrap);

                const check = document.createElement('span');
                check.className = 'material-symbols-outlined text-[18px] text-text-muted opacity-0';
                check.textContent = 'check';

                optBtn.append(optLeft, check);
                return optBtn;
            };

            const buildMenu = () => {
                menu.innerHTML = '';

                const noneOpt = makeOption({ uid: '', name: 'Sin asignar', dept: '', photo: '' });
                const noneAvatar = noneOpt.querySelector('.w-8');
                if (noneAvatar) {
                    noneAvatar.classList.remove('text-primary', 'border-primary/20', 'bg-primary/15');
                    noneAvatar.classList.add('bg-white/10', 'text-text-muted', 'border-border-dark');
                    noneAvatar.textContent = '-';
                }
                menu.appendChild(noneOpt);

                const users = Object.entries(usersByUid || {})
                    .map(([uid, user]) => ({ uid, ...user }))
                    .filter(entry => entry.uid);

                users.sort((a, b) => (a.username || a.email || '').localeCompare(b.username || b.email || ''));

                users.forEach(user => {
                    menu.appendChild(makeOption({
                        uid: user.uid,
                        name: user.username || user.email || user.uid,
                        dept: user.department || '',
                        photo: user.profile_picture || ''
                    }));
                });
            };

            const refreshMenuChecks = () => {
                const currentUid = String(assigneeUid || '').trim();
                Array.from(menu.querySelectorAll('button[data-uid]')).forEach((btn) => {
                    const isActive = String(btn.dataset.uid || '') === currentUid;
                    const check = btn.querySelector('.material-symbols-outlined');
                    if (check) check.classList.toggle('opacity-0', !isActive);
                });
            };

            const findClippingContainer = () => {
                let node = wrapper.parentElement;
                while (node && node !== document.body && node !== document.documentElement) {
                    const style = window.getComputedStyle(node);
                    const overflowY = style.overflowY;
                    const overflowX = style.overflowX;
                    if (
                        ['auto', 'scroll', 'hidden', 'clip'].includes(overflowY) ||
                        ['auto', 'scroll', 'hidden', 'clip'].includes(overflowX)
                    ) {
                        return node;
                    }
                    node = node.parentElement;
                }
                return document.documentElement;
            };

            const positionMenu = () => {
                const clipping = findClippingContainer();
                const clipRect = clipping.getBoundingClientRect();
                const btnRect = button.getBoundingClientRect();
                const padding = 8;

                menu.style.maxHeight = '';

                const wasHidden = menu.classList.contains('hidden');
                if (wasHidden) {
                    menu.classList.remove('hidden');
                    menu.style.visibility = 'hidden';
                }

                const menuRect = menu.getBoundingClientRect();
                const menuHeight = menuRect.height || 220;

                const availableBelow = clipRect.bottom - btnRect.bottom;
                const availableAbove = btnRect.top - clipRect.top;
                const shouldOpenUp = availableBelow < (menuHeight + padding) && availableAbove > availableBelow;

                menu.classList.remove('top-full', 'mt-2', 'bottom-full', 'mb-2');
                if (shouldOpenUp) {
                    menu.classList.add('bottom-full', 'mb-2');
                    const maxHeight = Math.max(160, Math.floor(availableAbove - padding));
                    menu.style.maxHeight = `${maxHeight}px`;
                } else {
                    menu.classList.add('top-full', 'mt-2');
                    const maxHeight = Math.max(160, Math.floor(availableBelow - padding));
                    menu.style.maxHeight = `${maxHeight}px`;
                }

                if (wasHidden) {
                    menu.style.visibility = '';
                    menu.classList.add('hidden');
                }
            };

            menu.addEventListener('click', (e) => e.stopPropagation());
            menu.addEventListener('click', async (e) => {
                const btn = e.target.closest('button[data-uid]');
                if (!btn) return;
                e.preventDefault();
                e.stopPropagation();
                if (!canEdit || saving) return;
                menu.classList.add('hidden');

                const nextUid = String(btn.dataset.uid || '').trim();
                setSaving(true);
                try {
                    const saved = await onChange(nextUid);
                    assigneeUid = saved ?? nextUid;
                    applyAssignee(assigneeUid);
                } catch (error) {
                    console.error('Error updating assignee:', error);
                    alert(`No se pudo asignar: ${error.message}`);
                } finally {
                    setSaving(false);
                }
            });

            button.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!canEdit) return;
                const isOpen = !menu.classList.contains('hidden');
                closeAllActionMenus(menu);
                if (isOpen) {
                    menu.classList.add('hidden');
                    return;
                }
                buildMenu();
                refreshMenuChecks();
                positionMenu();
                menu.classList.remove('hidden');
            });

            wrapper.append(button, menu);
            return wrapper;
        };

        const createStatusControl = ({ status, onChange }) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'relative flex-shrink-0';

            const button = document.createElement('button');
            button.type = 'button';

            const label = document.createElement('span');
            label.className = 'leading-none';

            const caret = document.createElement('span');
            caret.className = 'material-symbols-outlined text-[16px] leading-none opacity-70';
            caret.textContent = 'expand_more';

            button.append(label, caret);
            applyStatusChipStyle(button, label, status);

            const menu = document.createElement('div');
            menu.className = 'action-menu hidden absolute right-0 w-44 bg-white dark:bg-surface-dark border border-border-dark rounded-lg shadow-xl overflow-x-hidden overflow-y-auto z-50 text-gray-900 dark:text-white';

            const canEdit = Boolean(currentUser) && typeof onChange === 'function';
            button.disabled = !canEdit;
            button.classList.toggle('opacity-60', !canEdit);
            button.classList.toggle('cursor-not-allowed', !canEdit);

            let saving = false;
            const setSaving = (isSaving) => {
                saving = isSaving;
                button.disabled = isSaving || !canEdit;
                button.classList.toggle('opacity-60', button.disabled);
                button.classList.toggle('cursor-not-allowed', button.disabled);
            };

            STATUS_STEPS.forEach(option => {
                const optBtn = document.createElement('button');
                optBtn.type = 'button';
                optBtn.className = 'w-full flex items-center justify-between gap-2 px-4 py-2 text-sm text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-white/10 text-left';
                optBtn.dataset.status = option;

                const left = document.createElement('div');
                left.className = 'flex items-center gap-2';

                const dot = createStatusDot(option);
                const txt = document.createElement('span');
                txt.textContent = option;
                left.append(dot, txt);

                const check = document.createElement('span');
                check.className = 'material-symbols-outlined text-[18px] text-text-muted opacity-0';
                check.textContent = 'check';

                optBtn.append(left, check);

                optBtn.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    if (!canEdit || saving) return;
                    menu.classList.add('hidden');
                    const next = normalizeStatus(option);
                    setSaving(true);
                    try {
                        const saved = await onChange(next);
                        applyStatusChipStyle(button, label, saved || next);
                    } catch (error) {
                        console.error('Error updating status:', error);
                        alert(`No se pudo actualizar el estado: ${error.message}`);
                    } finally {
                        setSaving(false);
                    }
                });

                menu.appendChild(optBtn);
            });

            const refreshMenuChecks = () => {
                const current = normalizeStatus(label.textContent);
                Array.from(menu.querySelectorAll('button[data-status]')).forEach((btn) => {
                    const isActive = normalizeStatus(btn.dataset.status) === current;
                    const check = btn.querySelector('.material-symbols-outlined');
                    if (check) check.classList.toggle('opacity-0', !isActive);
                });
            };

            const findClippingContainer = () => {
                let node = wrapper.parentElement;
                while (node && node !== document.body && node !== document.documentElement) {
                    const style = window.getComputedStyle(node);
                    const overflowY = style.overflowY;
                    const overflowX = style.overflowX;
                    if (
                        ['auto', 'scroll', 'hidden', 'clip'].includes(overflowY) ||
                        ['auto', 'scroll', 'hidden', 'clip'].includes(overflowX)
                    ) {
                        return node;
                    }
                    node = node.parentElement;
                }
                return document.documentElement;
            };

            const positionMenu = () => {
                const clipping = findClippingContainer();
                const clipRect = clipping.getBoundingClientRect();
                const btnRect = button.getBoundingClientRect();
                const padding = 8;

                menu.style.maxHeight = '';

                const wasHidden = menu.classList.contains('hidden');
                if (wasHidden) {
                    menu.classList.remove('hidden');
                    menu.style.visibility = 'hidden';
                }

                const menuRect = menu.getBoundingClientRect();
                const menuHeight = menuRect.height || 140;

                const availableBelow = clipRect.bottom - btnRect.bottom;
                const availableAbove = btnRect.top - clipRect.top;
                const shouldOpenUp = availableBelow < (menuHeight + padding) && availableAbove > availableBelow;

                menu.classList.remove('top-full', 'mt-2', 'bottom-full', 'mb-2');
                if (shouldOpenUp) {
                    menu.classList.add('bottom-full', 'mb-2');
                    const maxHeight = Math.max(120, Math.floor(availableAbove - padding));
                    menu.style.maxHeight = `${maxHeight}px`;
                } else {
                    menu.classList.add('top-full', 'mt-2');
                    const maxHeight = Math.max(120, Math.floor(availableBelow - padding));
                    menu.style.maxHeight = `${maxHeight}px`;
                }

                if (wasHidden) {
                    menu.style.visibility = '';
                    menu.classList.add('hidden');
                }
            };

            menu.addEventListener('click', (e) => e.stopPropagation());

            button.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (!canEdit) return;
                const isOpen = !menu.classList.contains('hidden');
                closeAllActionMenus(menu);
                if (isOpen) {
                    menu.classList.add('hidden');
                    return;
                }
                refreshMenuChecks();
                positionMenu();
                menu.classList.remove('hidden');
            });

            wrapper.append(button, menu);
            return wrapper;
        };

        const makeSummary = (iconName, titleText, manageIdValue, statusValue = null, onStatusChange = null, assigneeUid = null, onAssigneeChange = null, itemPath = null, itemData = null, itemType = null) => {
            const summary = document.createElement('summary');
            summary.className = 'flex items-center justify-between gap-2 cursor-pointer select-none px-3 py-2 text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-white/5 rounded-lg';

            const left = document.createElement('div');
            left.className = 'flex items-center gap-2 min-w-0';

            const icon = document.createElement('span');
            icon.className = 'material-symbols-outlined text-text-muted';
            icon.textContent = iconName;

            const title = document.createElement('span');
            title.className = 'text-sm font-semibold truncate';
            title.textContent = titleText || '-';

            // ✅ AÑADIR manageId AL LEFT (después del nombre)
            const manageLink = createManageLink(manageIdValue);

            left.append(icon, title, manageLink);

            const right = document.createElement('div');
            right.className = 'flex items-center gap-3 min-w-0';
            if (statusValue !== null) right.appendChild(createStatusControl({ status: statusValue, onChange: onStatusChange }));
            if (assigneeUid !== null) {
                if (typeof onAssigneeChange === 'function') {
                    right.appendChild(createAssigneeControl({ assigneeUid, onChange: onAssigneeChange }));
                } else {
                    right.appendChild(createAssigneeBadge(assigneeUid));
                }
            }
            // ✅ Ya NO añadimos createManageLink aquí (se movió a left)

            // Añadir icono de configuración si se proporciona la información necesaria
            if (itemPath && itemData && itemType) {
                right.appendChild(createSettingsIcon(itemPath, itemData, itemType));
            }

            summary.append(left, right);
            return summary;
        };

        const makeRow = (iconName, titleText, manageIdValue, statusValue = null, onStatusChange = null, assigneeUid = null, onAssigneeChange = null, itemPath = null, itemData = null, itemType = null) => {
            const row = document.createElement('div');
            row.className = 'flex items-center justify-between gap-2 px-3 py-2 rounded-lg bg-white dark:bg-surface-dark border border-border-dark text-gray-900 dark:text-white';

            const left = document.createElement('div');
            left.className = 'flex items-center gap-2 min-w-0';

            const icon = document.createElement('span');
            icon.className = 'material-symbols-outlined text-text-muted text-[18px]';
            icon.textContent = iconName;

            const title = document.createElement('span');
            title.className = 'text-sm font-medium truncate';
            title.textContent = titleText || '-';

            // ✅ AÑADIR manageId AL LEFT (después del nombre)
            const manageLink = createManageLink(manageIdValue);

            left.append(icon, title, manageLink);

            const right = document.createElement('div');
            right.className = 'flex items-center gap-3 min-w-0';
            if (statusValue !== null) right.appendChild(createStatusControl({ status: statusValue, onChange: onStatusChange }));
            if (assigneeUid !== null) {
                if (typeof onAssigneeChange === 'function') {
                    right.appendChild(createAssigneeControl({ assigneeUid, onChange: onAssigneeChange }));
                } else {
                    right.appendChild(createAssigneeBadge(assigneeUid));
                }
            }
            // ✅ Ya NO añadimos createManageLink aquí (se movió a left)

            // Añadir icono de configuración si se proporciona la información necesaria
            if (itemPath && itemData && itemType) {
                right.appendChild(createSettingsIcon(itemPath, itemData, itemType));
            }

            row.append(left, right);
            return row;
        };

        const makeTaskBlock = (task, taskPath) => {
            const taskName = task?.name || 'Tarea';
            const subtasks = task?.subtasks || {};
            const subArray = Object.entries(subtasks || {})
                .map(([id, sub]) => ({ id: sub?.subtaskId || id, ...sub }))
                .filter(entry => entry && entry.id);
            const sortedSubtasks = sortActivities(subArray, getDetailSortMode('taskSubtasks'));

            const safeTaskPath = String(taskPath || '').trim();
            const onTaskStatusChange = safeTaskPath
                ? async (nextStatus) => {
                    const status = await updateStatusAtPath(safeTaskPath, nextStatus);
                    task.status = status;
                    return status;
                }
                : null;

            const onTaskAssigneeChange = safeTaskPath
                ? async (nextUid) => {
                    const uid = await updateAssigneeAtPath(safeTaskPath, nextUid);
                    task.assigneeUid = uid;
                    return uid;
                }
                : null;

            // Siempre hacer las tareas expandibles para permitir crear subtareas
            const details = document.createElement('details');
            details.className = 'border border-border-dark rounded-lg bg-white dark:bg-surface-dark';
            details.appendChild(makeSummary(
                'check_circle',
                taskName,
                task?.manageId,
                normalizeStatus(task?.status),
                onTaskStatusChange,
                task?.assigneeUid ?? '',
                onTaskAssigneeChange,
                safeTaskPath, // itemPath
                task, // itemData
                'task' // itemType
            ));

            const content = document.createElement('div');
            content.className = 'pl-5 pr-3 pb-3 flex flex-col gap-2';

            // Botón para crear subtareas dentro de la tarea
            const taskActionRow = document.createElement('div');
            taskActionRow.className = 'flex flex-wrap items-center gap-2 mb-2';
            taskActionRow.appendChild(makeActivityActionButton({
                label: 'Crear subtarea',
                icon: 'subdirectory_arrow_right',
                onClick: () => {
                    console.log('Crear subtarea - taskPath:', safeTaskPath);
                    if (!safeTaskPath) {
                        alert('Error: No se puede determinar la ruta de la tarea');
                        return;
                    }
                    createChildActivity({
                        label: 'subtarea',
                        type: 'subtask',
                        path: `${safeTaskPath}/subtasks`
                    });
                }
            }));
            content.appendChild(taskActionRow);

            if (!sortedSubtasks.length) {
                const msg = document.createElement('p');
                msg.className = 'text-text-muted text-sm';
                msg.textContent = 'No hay subtareas en esta tarea.';
                content.appendChild(msg);
            } else {
                content.appendChild(makeGroupHeader('Subtareas', 'taskSubtasks', {
                    className: 'mt-1',
                    labelClass: 'text-text-muted text-xs px-1'
                }));
                sortedSubtasks.forEach(sub => {
                    const subPath = safeTaskPath ? `${safeTaskPath}/subtasks/${sub.id}` : '';
                    const onSubStatusChange = subPath
                        ? async (nextStatus) => {
                            const status = await updateStatusAtPath(subPath, nextStatus);
                            sub.status = status;
                            return status;
                        }
                        : null;

                    const onSubAssigneeChange = subPath
                        ? async (nextUid) => {
                            const uid = await updateAssigneeAtPath(subPath, nextUid);
                            sub.assigneeUid = uid;
                            return uid;
                        }
                        : null;

                    content.appendChild(makeRow(
                        'subdirectory_arrow_right',
                        sub.name || 'Subtarea',
                        sub.manageId,
                        normalizeStatus(sub.status),
                        onSubStatusChange,
                        sub.assigneeUid ?? '',
                        onSubAssigneeChange,
                        subPath, // itemPath
                        sub, // itemData
                        'subtask' // itemType
                    ));
                });
            }

            details.appendChild(content);
            return details;
        };

        const renderActivities = (result) => {
            if (!activitiesList) return;
            activitiesList.innerHTML = '';

            const { type, item, ids } = result || {};
            const empty = (text) => {
                const msg = document.createElement('p');
                msg.className = 'text-text-muted text-sm';
                msg.textContent = text;
                activitiesList.appendChild(msg);
            };

            if (!item) {
                empty('No hay elementos.');
                return;
            }

            const clientId = String(ids?.clientId || '').trim();
            const projectId = String(ids?.projectId || '').trim();
            const productId = String(ids?.productId || '').trim();
            const taskId = String(ids?.taskId || '').trim();
            const clientRoot = clientId
                ? loadedClients.find(c => c.id === clientId)
                : null;

            const actionRow = document.createElement('div');
            actionRow.className = 'flex flex-wrap items-center gap-2 mb-3';
            const addActions = () => {
                if (!actionRow.children.length) return;
                activitiesList.appendChild(actionRow);
            };

            if (type === 'client') {
                if (clientId) {
                    actionRow.appendChild(makeActivityActionButton({
                        label: 'Crear proyecto',
                        icon: 'add_box',
                        onClick: () => createChildActivity({
                            label: 'proyecto',
                            type: 'project',
                            path: `clients/${clientId}/projects`
                        })
                    }));
                }
                addActions();
                const clientItem = clientRoot || item;
                const projects = clientItem?.projects || {};
                const projectItems = sortActivities(
                    mapEntriesToItems(Object.entries(projects || {}).filter(([, proj]) => proj)),
                    getDetailSortMode('projects')
                );

                if (!projectItems.length) {
                    empty('No hay proyectos');
                    return;
                }

                activitiesList.appendChild(makeGroupHeader('Proyectos', 'projects', { className: 'mb-2' }));

                projectItems.forEach((projectItem) => {
                    const projectId = projectItem.id;
                    const proj = projectItem.ref;
                    const projPath = clientId ? `clients/${clientId}/projects/${projectId}` : '';
                    const onProjStatusChange = projPath
                        ? async (nextStatus) => {
                            const status = await updateStatusAtPath(projPath, nextStatus);
                            proj.status = status;
                            return status;
                        }
                        : null;

                    const projDetails = document.createElement('details');
                    projDetails.className = 'border border-border-dark rounded-lg bg-white dark:bg-surface-dark';
                    projDetails.appendChild(makeSummary(
                        'layers',
                        proj.name || 'Proyecto',
                        proj.manageId,
                        normalizeStatus(proj.status),
                        onProjStatusChange,
                        null, // assigneeUid
                        null, // onAssigneeChange
                        projPath, // itemPath
                        proj, // itemData
                        'project' // itemType
                    ));

                    const projContent = document.createElement('div');
                    projContent.className = 'pl-5 pr-3 pb-3 flex flex-col gap-3';

                    // Botones de acción para crear actividades dentro del proyecto
                    const projActionRow = document.createElement('div');
                    projActionRow.className = 'flex flex-wrap items-center gap-2 mb-2';

                    projActionRow.appendChild(makeActivityActionButton({
                        label: 'Crear producto',
                        icon: 'category',
                        onClick: () => {
                            console.log('Crear producto - projPath:', projPath, 'clientId:', clientId, 'projectId:', projectId);
                            if (!projPath) {
                                alert('Error: No se puede determinar la ruta del proyecto');
                                return;
                            }
                            createChildActivity({
                                label: 'producto',
                                type: 'product',
                                path: `${projPath}/products`
                            });
                        }
                    }));
                    projActionRow.appendChild(makeActivityActionButton({
                        label: 'Crear tarea',
                        icon: 'check_circle',
                        onClick: () => {
                            console.log('Crear tarea - projPath:', projPath, 'clientId:', clientId, 'projectId:', projectId);
                            if (!projPath) {
                                alert('Error: No se puede determinar la ruta del proyecto');
                                return;
                            }
                            createChildActivity({
                                label: 'tarea',
                                type: 'task',
                                path: `${projPath}/tasks`
                            });
                        }
                    }));
                    projContent.appendChild(projActionRow);

                    const projTasks = proj.tasks || {};
                    const projTaskItems = sortActivities(
                        mapEntriesToItems(Object.entries(projTasks || {}).filter(([, t]) => t)),
                        getDetailSortMode('projectTasks')
                    );
                    if (projTaskItems.length) {
                        projContent.appendChild(makeGroupHeader('Tareas (sin producto)', 'projectTasks', {
                            className: 'mt-1',
                            labelClass: 'text-text-muted text-xs px-1'
                        }));
                        projTaskItems.forEach((taskItem) => {
                            const taskId = taskItem.id;
                            const task = taskItem.ref;
                            const taskPath = projPath ? `${projPath}/tasks/${taskId}` : '';
                            projContent.appendChild(makeTaskBlock(task, taskPath));
                        });
                    }

                    const products = proj.products || {};
                    const productItems = sortActivities(
                        mapEntriesToItems(Object.entries(products || {}).filter(([, prod]) => prod)),
                        getDetailSortMode('projectProducts')
                    );
                    if (productItems.length) {
                        projContent.appendChild(makeGroupHeader('Productos', 'projectProducts', {
                            className: 'mt-1',
                            labelClass: 'text-text-muted text-xs px-1'
                        }));

                        productItems.forEach((productItem) => {
                            const productId = productItem.id;
                            const prod = productItem.ref;
                            const prodPath = projPath ? `${projPath}/products/${productId}` : '';
                            const onProdStatusChange = prodPath
                                ? async (nextStatus) => {
                                    const status = await updateStatusAtPath(prodPath, nextStatus);
                                    prod.status = status;
                                    return status;
                                }
                                : null;

                            const prodDetails = document.createElement('details');
                            prodDetails.className = 'border border-border-dark/70 rounded-lg bg-white dark:bg-background-dark/10';
                            prodDetails.appendChild(makeSummary(
                                'category',
                                prod.name || 'Producto',
                                prod.manageId,
                                normalizeStatus(prod.status),
                                onProdStatusChange,
                                null, // assigneeUid
                                null, // onAssigneeChange
                                prodPath, // itemPath
                                prod, // itemData
                                'product' // itemType
                            ));

                            const prodContent = document.createElement('div');
                            prodContent.className = 'pl-5 pr-3 pb-3 flex flex-col gap-2';

                            // Botón para crear tareas dentro del producto
                            const prodActionRow = document.createElement('div');
                            prodActionRow.className = 'flex flex-wrap items-center gap-2 mb-2';
                            prodActionRow.appendChild(makeActivityActionButton({
                                label: 'Crear tarea',
                                icon: 'check_circle',
                                onClick: () => {
                                    console.log('Crear tarea en producto - prodPath:', prodPath);
                                    if (!prodPath) {
                                        alert('Error: No se puede determinar la ruta del producto');
                                        return;
                                    }
                                    createChildActivity({
                                        label: 'tarea',
                                        type: 'task',
                                        path: `${prodPath}/tasks`
                                    });
                                }
                            }));
                            prodContent.appendChild(prodActionRow);

                            const tasks = prod.tasks || {};
                            const taskItems = sortActivities(
                                mapEntriesToItems(Object.entries(tasks || {}).filter(([, t]) => t)),
                                getDetailSortMode('productTasks')
                            );

                            if (!taskItems.length) {
                                const msg = document.createElement('p');
                                msg.className = 'text-text-muted text-sm';
                                msg.textContent = 'No hay tareas en este producto.';
                                prodContent.appendChild(msg);
                            } else {
                                prodContent.appendChild(makeGroupHeader('Tareas', 'productTasks', {
                                    className: 'mt-1',
                                    labelClass: 'text-text-muted text-xs px-1'
                                }));
                                taskItems.forEach((taskItem) => {
                                    const taskId = taskItem.id;
                                    const task = taskItem.ref;
                                    const taskPath = prodPath ? `${prodPath}/tasks/${taskId}` : '';
                                    prodContent.appendChild(makeTaskBlock(task, taskPath));
                                });
                            }

                            prodDetails.appendChild(prodContent);
                            projContent.appendChild(prodDetails);
                        });
                    }

                    if (!projTaskItems.length && !productItems.length) {
                        const msg = document.createElement('p');
                        msg.className = 'text-text-muted text-sm';
                        msg.textContent = 'No hay actividades en este proyecto.';
                        projContent.appendChild(msg);
                    }

                    projDetails.appendChild(projContent);
                    activitiesList.appendChild(projDetails);
                });

                return;
            }

            if (type === 'project') {
                const projectItem = clientRoot?.projects?.[projectId] || item;
                const projPath = clientId && projectId ? `clients/${clientId}/projects/${projectId}` : '';
                if (clientId && projectId) {
                    actionRow.appendChild(makeActivityActionButton({
                        label: 'Crear producto',
                        icon: 'category',
                        onClick: () => createChildActivity({
                            label: 'producto',
                            type: 'product',
                            path: `${projPath}/products`
                        })
                    }));
                    actionRow.appendChild(makeActivityActionButton({
                        label: 'Crear tarea',
                        icon: 'check_circle',
                        onClick: () => createChildActivity({
                            label: 'tarea',
                            type: 'task',
                            path: `${projPath}/tasks`
                        })
                    }));
                }
                addActions();

                const projTasks = projectItem?.tasks || {};
                const projTaskItems = sortActivities(
                    mapEntriesToItems(Object.entries(projTasks || {}).filter(([, t]) => t)),
                    getDetailSortMode('projectTasks')
                );
                if (projTaskItems.length) {
                    activitiesList.appendChild(makeGroupHeader('Tareas (sin producto)', 'projectTasks', {
                        className: 'mb-2',
                        labelClass: 'text-text-muted text-xs px-1'
                    }));
                    projTaskItems.forEach((taskItem) => {
                        const taskId = taskItem.id;
                        const task = taskItem.ref;
                        const taskPath = projPath ? `${projPath}/tasks/${taskId}` : '';
                        activitiesList.appendChild(makeTaskBlock(task, taskPath));
                    });
                }

                const products = projectItem?.products || {};
                const productItems = sortActivities(
                    mapEntriesToItems(Object.entries(products || {}).filter(([, prod]) => prod)),
                    getDetailSortMode('projectProducts')
                );
                if (productItems.length) {
                    activitiesList.appendChild(makeGroupHeader('Productos', 'projectProducts', {
                        className: 'mb-2 pt-2',
                        labelClass: 'text-text-muted text-xs px-1'
                    }));

                    productItems.forEach((productItem) => {
                        const productId = productItem.id;
                        const prod = productItem.ref;
                        const prodPath = projPath ? `${projPath}/products/${productId}` : '';
                        const onProdStatusChange = prodPath
                            ? async (nextStatus) => {
                                const status = await updateStatusAtPath(prodPath, nextStatus);
                                prod.status = status;
                                return status;
                            }
                            : null;

                        const prodDetails = document.createElement('details');
                        prodDetails.className = 'border border-border-dark rounded-lg bg-white dark:bg-surface-dark';
                        prodDetails.appendChild(makeSummary(
                            'category',
                            prod.name || 'Producto',
                            prod.manageId,
                            normalizeStatus(prod.status),
                            onProdStatusChange,
                            null, // assigneeUid
                            null, // onAssigneeChange
                            prodPath, // itemPath
                            prod, // itemData
                            'product' // itemType
                        ));

                        const prodContent = document.createElement('div');
                        prodContent.className = 'pl-5 pr-3 pb-3 flex flex-col gap-2';

                        // Botón para crear tareas dentro del producto
                        const prodActionRow = document.createElement('div');
                        prodActionRow.className = 'flex flex-wrap items-center gap-2 mb-2';
                        prodActionRow.appendChild(makeActivityActionButton({
                            label: 'Crear tarea',
                            icon: 'check_circle',
                            onClick: () => {
                                console.log('Crear tarea en producto (vista proyecto) - prodPath:', prodPath);
                                if (!prodPath) {
                                    alert('Error: No se puede determinar la ruta del producto');
                                    return;
                                }
                                createChildActivity({
                                    label: 'tarea',
                                    type: 'task',
                                    path: `${prodPath}/tasks`
                                });
                            }
                        }));
                        prodContent.appendChild(prodActionRow);

                        const tasks = prod.tasks || {};
                        const taskItems = sortActivities(
                            mapEntriesToItems(Object.entries(tasks || {}).filter(([, t]) => t)),
                            getDetailSortMode('productTasks')
                        );
                        if (!taskItems.length) {
                            const msg = document.createElement('p');
                            msg.className = 'text-text-muted text-sm';
                            msg.textContent = 'No hay tareas en este producto.';
                            prodContent.appendChild(msg);
                        } else {
                            prodContent.appendChild(makeGroupHeader('Tareas', 'productTasks', {
                                className: 'mt-1',
                                labelClass: 'text-text-muted text-xs px-1'
                            }));
                            taskItems.forEach((taskItem) => {
                                const taskId = taskItem.id;
                                const task = taskItem.ref;
                                const taskPath = prodPath ? `${prodPath}/tasks/${taskId}` : '';
                                prodContent.appendChild(makeTaskBlock(task, taskPath));
                            });
                        }

                        prodDetails.appendChild(prodContent);
                        activitiesList.appendChild(prodDetails);
                    });
                }

                if (!projTaskItems.length && !productItems.length) {
                    empty('No hay actividades en este proyecto.');
                }
                return;
            }

            if (type === 'product') {
                const prodPath = clientId && projectId && productId
                    ? `clients/${clientId}/projects/${projectId}/products/${productId}`
                    : '';
                if (clientId && projectId && productId) {
                    actionRow.appendChild(makeActivityActionButton({
                        label: 'Crear tarea',
                        icon: 'check_circle',
                        onClick: () => createChildActivity({
                            label: 'tarea',
                            type: 'task',
                            path: `${prodPath}/tasks`
                        })
                    }));
                }
                addActions();

                const productItem = clientRoot?.projects?.[projectId]?.products?.[productId] || item;
                const tasks = productItem?.tasks || {};
                const taskItems = sortActivities(
                    mapEntriesToItems(Object.entries(tasks || {}).filter(([, t]) => t)),
                    getDetailSortMode('productTasks')
                );
                if (!taskItems.length) {
                    empty('No hay tareas en este producto.');
                    return;
                }
                activitiesList.appendChild(makeGroupHeader('Tareas', 'productTasks', {
                    className: 'mb-2',
                    labelClass: 'text-text-muted text-xs px-1'
                }));
                taskItems.forEach((taskItem) => {
                    const taskId = taskItem.id;
                    const task = taskItem.ref;
                    const taskPath = prodPath ? `${prodPath}/tasks/${taskId}` : '';
                    activitiesList.appendChild(makeTaskBlock(task, taskPath));
                });
                return;
            }

            if (type === 'task') {
                const taskPath = currentItemPath || buildItemPath(ids, 'task') || '';
                const taskItem = productId
                    ? clientRoot?.projects?.[projectId]?.products?.[productId]?.tasks?.[taskId]
                    : clientRoot?.projects?.[projectId]?.tasks?.[taskId];
                const subtasks = (taskItem || item)?.subtasks || {};
                if (taskPath) {
                    actionRow.appendChild(makeActivityActionButton({
                        label: 'Crear subtarea',
                        icon: 'subdirectory_arrow_right',
                        onClick: () => createChildActivity({
                            label: 'subtarea',
                            type: 'subtask',
                            path: `${taskPath}/subtasks`
                        })
                    }));
                }
                addActions();
                const subItems = sortActivities(
                    mapEntriesToItems(Object.entries(subtasks || {}).filter(([, s]) => s)),
                    getDetailSortMode('taskSubtasks')
                );
                if (!subItems.length) {
                    empty('No hay subtareas en esta tarea.');
                    return;
                }
                activitiesList.appendChild(makeGroupHeader('Subtareas', 'taskSubtasks', {
                    className: 'mb-2',
                    labelClass: 'text-text-muted text-xs px-1'
                }));
                subItems.forEach((subItem) => {
                    const subtaskId = subItem.id;
                    const sub = subItem.ref;
                    const subPath = taskPath ? `${taskPath}/subtasks/${subtaskId}` : '';
                    const onSubStatusChange = subPath
                        ? async (nextStatus) => {
                            const status = await updateStatusAtPath(subPath, nextStatus);
                            sub.status = status;
                            return status;
                        }
                        : null;

                    const onSubAssigneeChange = subPath
                        ? async (nextUid) => {
                            const uid = await updateAssigneeAtPath(subPath, nextUid);
                            sub.assigneeUid = uid;
                            return uid;
                        }
                        : null;

                    activitiesList.appendChild(makeRow(
                        'subdirectory_arrow_right',
                        sub.name || 'Subtarea',
                        sub.manageId,
                        normalizeStatus(sub.status),
                        onSubStatusChange,
                        sub.assigneeUid ?? '',
                        onSubAssigneeChange,
                        subPath, // itemPath
                        sub, // itemData
                        'subtask' // itemType
                    ));
                });
                return;
            }

            empty('No hay actividades inferiores.');
        };

        const renderComments = (snapshotVal) => {
            if (!commentsList) return;
            commentsList.innerHTML = '';
            const entries = Object.entries(snapshotVal || {}).map(([id, value]) => ({ id, ...value }));
            entries.sort((a, b) => {
                const da = new Date(a.createdAt || 0).getTime();
                const db = new Date(b.createdAt || 0).getTime();
                return da - db;
            });
            if (commentCount) commentCount.textContent = `${entries.length}`;

            if (!entries.length) {
                const empty = document.createElement('p');
                empty.className = 'text-text-muted text-sm';
                empty.textContent = 'Todav\u00EDa no hay comentarios';
                commentsList.appendChild(empty);
                return;
            }

            entries.forEach((entry) => {
                const authorName = entry.userName || entry.userId || 'Usuario';
                const authorPhoto = entry.userPhoto || entry.userPhotoUrl || '';
                const authorDept = entry.userDepartment || '';

                const card = document.createElement('div');
                card.id = `comment-${entry.id}`;
                card.className = 'flex items-start gap-3 scroll-mt-24';

                const header = document.createElement('div');
                header.className = 'flex flex-col gap-1 min-w-0';

                const left = document.createElement('div');
                left.className = 'flex items-start gap-3 min-w-0';

                const avatar = document.createElement('div');
                avatar.className = 'w-9 h-9 rounded-full bg-primary/20 text-primary border border-primary/30 flex items-center justify-center font-bold text-sm overflow-hidden bg-center bg-cover bg-no-repeat shrink-0';
                renderAvatar(avatar, authorName, authorPhoto);

                const authorMeta = document.createElement('div');
                authorMeta.className = 'flex flex-col min-w-0 leading-tight';

                const nameRow = document.createElement('div');
                nameRow.className = 'flex items-center gap-2 min-w-0 flex-wrap';

                const author = document.createElement('span');
                author.className = 'text-sm font-semibold text-gray-900 dark:text-white truncate';
                author.textContent = authorName;

                const text = document.createElement('span');
                text.className = 'text-sm text-gray-900 dark:text-white break-words';
                text.textContent = entry.text || '';

                const date = document.createElement('span');
                date.className = 'text-xs text-text-muted whitespace-nowrap';
                date.textContent = formatDate(entry.createdAt);

                nameRow.append(author, date, text);
                authorMeta.appendChild(nameRow);

                if (authorDept) {
                    const dept = document.createElement('span');
                    dept.className = 'text-xs text-text-muted truncate';
                    dept.textContent = authorDept;
                    authorMeta.appendChild(dept);
                }

                left.append(avatar, authorMeta);
                header.append(left);
                card.append(header);
                commentsList.appendChild(card);

            });
        };

        const subscribeToComments = () => {
            if (commentsUnsubscribe) commentsUnsubscribe();
            if (!currentItemPath) return;
            const commentsRef = ref(database, `${currentItemPath}/comments`);
            commentsUnsubscribe = onValue(commentsRef, (snap) => {
                renderComments(snap.val());
            });
        };

        const updateAuthUI = () => {
            const canEdit = Boolean(currentUser);
            const helperText = canEdit
                ? `Comentando como ${getCurrentDisplayName()}`
                : 'Inicia sesi\u00F3n para comentar.';
            if (commentHelper) commentHelper.textContent = helperText;

            [descriptionInput, saveDescriptionButton, editDescriptionButton, commentInput, commentButton].forEach(el => {
                if (!el) return;
                el.disabled = !canEdit;
                el.classList.toggle('opacity-60', !canEdit);
            });
            if (!canEdit && descriptionEditing) {
                setDescriptionEditing(false);
            }

            const canEditDetails = canEdit && !detailFieldsSaving;
            const itemHasChildren = currentResult?.item && hasChildren(currentResult.item, currentItemType);

            [estimatedHoursInput, workDateInput].forEach(el => {
                if (!el) return;
                el.disabled = !canEditDetails;
                el.classList.toggle('opacity-60', !canEditDetails);
            });

            // Handle timeSpentInput separately because it might be disabled due to children
            if (timeSpentInput && !itemHasChildren) {
                timeSpentInput.disabled = !canEditDetails;
                timeSpentInput.classList.toggle('opacity-60', !canEditDetails);
            }

            const canEditStatus = canEdit && STATUS_TYPES.has(currentItemType) && !statusSaving;
            statusStepButtons.forEach(btn => {
                btn.disabled = !canEditStatus;
                btn.classList.toggle('opacity-60', !canEditStatus);
                btn.classList.toggle('cursor-not-allowed', !canEditStatus);
            });
            if (statusHelper) {
                if (!STATUS_TYPES.has(currentItemType)) {
                    statusHelper.textContent = '';
                } else if (statusSaving) {
                    statusHelper.textContent = 'Actualizando estado...';
                } else {
                    statusHelper.textContent = canEdit ? 'Haz clic en un estado para cambiarlo.' : 'Inicia sesi\u00F3n para cambiar el estado.';
                }
            }

            const canEditAssignee = canEdit && ASSIGNEE_TYPES.has(currentItemType) && !assigneeSaving;
            if (assigneeToggle) {
                assigneeToggle.disabled = !canEditAssignee;
                assigneeToggle.classList.toggle('opacity-60', !canEditAssignee);
                assigneeToggle.classList.toggle('cursor-not-allowed', !canEditAssignee);
            }
            if (!canEditAssignee) {
                assigneeMenu?.classList.add('hidden');
            }

            updateHeaderUser();
        };

        const populateView = (result) => {
            const { type, item, trail } = result;
            const title = item.name || TYPE_LABELS[type] || 'Detalle';
            setText('header-title', title);
            setText('header-manage', item.manageId || manageId || '-');
            setText('item-title', title);
            setText('item-manage', item.manageId || manageId || '-');
            setText('type-chip', TYPE_LABELS[type] || 'Detalle');
            setText('created-chip', formatDate(item.createdAt));

            const descText = item.description || '';
            if (descriptionInput) descriptionInput.value = descText;
            setDescriptionView(descText);
            setDescriptionEditing(false);
            setDetailFields(item);

            currentItemType = type;
            currentItemStatus = normalizeStatus(item.status);
            if (statusSave) statusSave.textContent = '';
            renderStatusFlow();

            currentAssigneeUid = String(item.assigneeUid || '').trim();
            if (assigneeSave) assigneeSave.textContent = '';
            renderAssigneeSection();

            renderBreadcrumb(trail);
            renderActivities(result);
            updateAuthUI();
        };

        const loadData = async () => {
            if (!manageId) {
                showError('No se encontr\u00F3 un manageId v\u00E1lido en la URL.');
                return;
            }
            try {
                const snap = await get(ref(database, 'clients'));
                const data = snap.val() || {};
                loadedClients = Object.keys(data).map(key => ({ id: key, ...data[key] }));
                const found = findByManageId(loadedClients, manageId);
                if (!found) {
                    showError(`No se encontr\u00F3 informaci\u00F3n para ${manageId}.`);
                    return;
                }
                currentResult = found;
                currentItemPath = buildItemPath(found.ids, found.type);
                populateView(found);
                subscribeToComments();
            } catch (err) {
                console.error(err);
                showError(err.message || 'Error cargando datos.');
            }
        };

        const saveDescription = async () => {
            if (!currentUser) {
                alert('Debes iniciar sesi\u00F3n para actualizar la descripci\u00F3n.');
                return;
            }
            if (!currentItemPath) return;
            const text = (descriptionInput?.value || '').trim();
            if (descriptionStatus) descriptionStatus.textContent = 'Guardando...';
            try {
                await update(ref(database, currentItemPath), { description: text });
                const parsed = parseClientPath(currentItemPath);
                if (parsed?.clientId) {
                    const label = TYPE_LABELS[currentItemType] || TYPE_LABELS[parsed.type] || 'Elemento';
                    const itemName = currentResult?.item?.name || label;
                    try {
                        await push(ref(database, `clients/${parsed.clientId}/activity_logs`), {
                            actorUid: currentUser.uid,
                            actorName: getCurrentDisplayName(),
                            description: `Actualiz\u00F3 descripci\u00F3n de ${label} \"${itemName}\".`,
                            timestamp: serverTimestamp(),
                            action: 'description_update',
                            path: currentItemPath,
                            entityType: parsed.type
                        });
                    } catch (e) {
                        console.warn('No se pudo registrar el log de actividad:', e);
                    }
                }
                setDescriptionView(text);
                setDescriptionEditing(false);
                if (descriptionStatus) {
                    descriptionStatus.textContent = 'Descripci\u00F3n guardada';
                    setTimeout(() => { descriptionStatus.textContent = ''; }, 2000);
                }
            } catch (err) {
                console.error(err);
                if (descriptionStatus) descriptionStatus.textContent = 'No se pudo guardar';
                showError(err.message || 'Error guardando la descripci\u00F3n.');
            }
        };

        const submitComment = async () => {
            if (!currentUser) {
                alert('Debes iniciar sesi\u00F3n para comentar.');
                return;
            }
            if (!currentItemPath) return;
            const text = (commentInput?.value || '').trim();
            if (!text || !commentButton) return;
            commentButton.textContent = 'Publicando...';
            commentButton.disabled = true;
            try {
                await push(ref(database, `${currentItemPath}/comments`), {
                    text,
                    userId: currentUser.uid,
                    userName: getCurrentDisplayName(),
                    userDepartment: getCurrentDepartment(),
                    userPhoto: getCurrentPhotoUrl(),
                    createdAt: new Date().toISOString()
                });
                if (commentInput) commentInput.value = '';
            } catch (err) {
                console.error(err);
                showError(err.message || 'No se pudo publicar el comentario.');
            } finally {
                commentButton.innerHTML = commentButtonDefaultHtml;
                updateAuthUI();
            }
        };

        onAuthStateChanged(auth, async (user) => {
            currentUser = user;
            if (user) {
                subscribeUsers();
                try {
                    const snap = await get(ref(database, `users/${user.uid}`));
                    currentUserProfile = snap.val();
                } catch (e) {
                    console.warn('No se pudo cargar el perfil del usuario', e);
                }
            } else {
                if (usersUnsubscribe) usersUnsubscribe();
                usersUnsubscribe = null;
                usersByUid = {};
                currentUserProfile = null;
            }
            updateAuthUI();
        });

        editDescriptionButton?.addEventListener('click', (e) => {
            e.preventDefault();
            if (!currentUser) {
                alert('Debes iniciar sesi\u00F3n para editar la descripci\u00F3n.');
                return;
            }
            if (descriptionEditing) {
                const viewText = descriptionView?.textContent || '';
                if (descriptionInput) {
                    descriptionInput.value = viewText === 'Sin descripci\u00F3n' ? '' : viewText;
                }
                setDescriptionEditing(false);
                return;
            }
            setDescriptionEditing(true);
            const viewText = descriptionView?.textContent || '';
            if (descriptionInput && viewText === 'Sin descripci\u00F3n') {
                descriptionInput.value = '';
            }
        });
        saveDescriptionButton?.addEventListener('click', saveDescription);
        estimatedHoursInput?.addEventListener('change', () => {
            saveDetailFields();
            updateTimeProgressBar();
        });
        estimatedHoursInput?.addEventListener('input', updateTimeProgressBar);
        timeSpentInput?.addEventListener('change', () => {
            saveDetailFields();
            updateTimeProgressBar();
        });
        timeSpentInput?.addEventListener('input', updateTimeProgressBar);
        workDateInput?.addEventListener('change', saveDetailFields);
        commentButton?.addEventListener('click', submitComment);
        qs('open-dashboard')?.addEventListener('click', () => {
            const target = `maindashboard.html?r=${Date.now()}`;
            window.top.location.href = target;
        });
        statusStepButtons.forEach(btn => {
            btn.addEventListener('click', () => saveStatus(btn.dataset.statusStep));
        });

        assigneeToggle?.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!assigneeMenu) return;
            const canOpen = Boolean(currentUser) && ASSIGNEE_TYPES.has(currentItemType) && !assigneeSaving;
            if (!canOpen) return;
            const isOpen = !assigneeMenu.classList.contains('hidden');
            closeAllActionMenus(assigneeMenu);
            if (isOpen) {
                assigneeMenu.classList.add('hidden');
                return;
            }
            buildAssigneeMenu();
            positionAssigneeMenu();
            assigneeMenu.classList.remove('hidden');
        });

        assigneeMenu?.addEventListener('click', (e) => {
            const btn = e.target.closest('button[data-uid]');
            if (!btn) return;
            e.preventDefault();
            e.stopPropagation();
            assigneeMenu.classList.add('hidden');
            saveAssignee(btn.dataset.uid);
        });

        document.addEventListener('click', () => closeAllActionMenus());

        // ========== FUNCIONES PARA EL MODAL DE CREACIÓN DE ACTIVIDAD ==========

        // Variables globales para el modal de creación
        let createActivityResolve = null;
        let createActivityReject = null;

        // Abrir modal de creación de actividad
        const openCreateActivityModal = (label) => {
            return new Promise((resolve, reject) => {
                const modal = document.getElementById('create-activity-modal');
                const title = document.getElementById('create-activity-title');
                const nameLabel = document.getElementById('activity-name-label');
                const nameInput = document.getElementById('activity-name-input');
                const form = document.getElementById('create-activity-form');

                if (!modal || !title || !nameLabel || !nameInput || !form) {
                    reject(new Error('Modal elements not found'));
                    return;
                }

                // Configurar textos según el tipo
                const labelCapitalized = label.charAt(0).toUpperCase() + label.slice(1);
                title.textContent = `Añadir ${labelCapitalized}`;
                nameLabel.textContent = `Nombre del ${labelCapitalized}`;
                nameInput.placeholder = `Escribe el nombre del ${label}...`;

                // Limpiar input
                nameInput.value = '';

                // Guardar resolve/reject
                createActivityResolve = resolve;
                createActivityReject = reject;

                // Mostrar modal
                modal.classList.remove('hidden');

                // Focus en input
                setTimeout(() => nameInput.focus(), 100);
            });
        };

        // Cerrar modal de creación de actividad
        const closeCreateActivityModal = (name = null) => {
            const modal = document.getElementById('create-activity-modal');
            const nameInput = document.getElementById('activity-name-input');

            if (modal) {
                modal.classList.add('hidden');
            }

            if (nameInput) {
                nameInput.value = '';
            }

            if (createActivityResolve) {
                createActivityResolve(name);
                createActivityResolve = null;
                createActivityReject = null;
            }
        };

        // Configurar event listeners del modal
        const setupCreateActivityModal = () => {
            const modal = document.getElementById('create-activity-modal');
            const closeBtn = document.getElementById('close-create-activity-modal');
            const cancelBtn = document.getElementById('cancel-create-activity');
            const form = document.getElementById('create-activity-form');

            if (closeBtn) {
                closeBtn.addEventListener('click', () => closeCreateActivityModal(null));
            }

            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => closeCreateActivityModal(null));
            }

            if (form) {
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const nameInput = document.getElementById('activity-name-input');
                    const name = nameInput?.value?.trim() || '';
                    closeCreateActivityModal(name);
                });
            }

            if (modal) {
                // Cerrar al hacer clic fuera del modal
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeCreateActivityModal(null);
                    }
                });
            }
        };

        // Configurar modal al cargar el DOM
        setupCreateActivityModal();

        loadData();
    </script>

    <!-- Modal para Crear Actividad -->
    <div id="create-activity-modal" class="hidden fixed inset-0 z-50 flex items-center justify-center bg-black/50 backdrop-blur-sm transition-opacity">
        <div class="w-full max-w-md bg-white dark:bg-surface-darker rounded-2xl shadow-2xl p-8 m-4">
            <div class="flex justify-between items-center mb-6">
                <h2 id="create-activity-title" class="text-gray-900 dark:text-white text-2xl font-bold">Añadir Actividad</h2>
                <button id="close-create-activity-modal" class="size-8 rounded-full hover:bg-white/10 flex items-center justify-center transition-colors">
                    <span class="material-symbols-outlined text-text-muted">close</span>
                </button>
            </div>
            <form id="create-activity-form">
                <div class="flex flex-col gap-4">
                    <div>
                        <label for="activity-name-input" id="activity-name-label" class="text-sm font-medium text-text-muted mb-2 block">Nombre de la Actividad</label>
                        <input
                            type="text"
                            id="activity-name-input"
                            name="activity-name"
                            required
                            autocomplete="off"
                            class="block w-full bg-white dark:bg-surface-dark border border-border-dark rounded-lg py-2.5 px-4 text-gray-900 dark:text-white focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary transition-all"
                            placeholder="Escribe el nombre..."
                        />
                    </div>
                    <div class="flex justify-end gap-4 mt-4">
                        <button
                            type="button"
                            id="cancel-create-activity"
                            class="px-5 py-2.5 text-sm font-medium text-text-muted bg-white/5 rounded-lg hover:bg-white/10 transition-colors"
                        >
                            Cancelar
                        </button>
                        <button
                            type="submit"
                            class="px-5 py-2.5 text-sm font-medium text-white bg-primary hover:bg-primary/90 rounded-lg shadow-lg shadow-primary/30 transition-all"
                        >
                            Crear
                        </button>
                    </div>
                </div>
            </form>
        </div>
    </div>
</body>
</html>



